// Generated by CoffeeScript 1.10.0
(function() {
  var makeBuffer, textureCache;

  textureCache = this.cc.TextureCache.getInstance();

  makeBuffer = function(width, height, insertAfterSelector) {
    var buffer;
    buffer = $('<canvas />')[0];
    buffer.width = width;
    buffer.height = height;
    if (insertAfterSelector) {
      $(buffer).insertAfter($(insertAfterSelector).css('display', 'inline-block')[0]).css({
        width: 768,
        height: 768,
        display: 'inline-block',
        left: 1024
      });
    }
    return buffer;
  };

  this.Background = {
    create: function(options) {
      var bgBuffer, bgSprite, binSize, chunkHeight, chunkWidth, chunkX, chunkY, ctx, ctxs, ctxsArray, doodadsSpriteFrameFunction, fgBuffer, fgSprite, height, i, modHeight, modWidth, parentSprite, ref, results, spatialHash, spriteFrame, spriteFrameOffset, spriteFrameRect, spriteFrames, tileMap, tileMapSize, tileSize, tileSpriteFrameFunction, transitionSpriteFrameFunction, width, x, y;
      this.options = options;
      tileMap = this.options.tileMap;
      tileMapSize = this.options.tileMapSize;
      tileSize = this.options.tileSize;
      parentSprite = this.options.parentSprite;
      spatialHash = this.options.spatialHash;
      tileSpriteFrameFunction = this.options.tileSpriteFrameFunction;
      transitionSpriteFrameFunction = this.options.transitionSpriteFrameFunction;
      doodadsSpriteFrameFunction = this.options.doodadsSpriteFrameFunction;
      width = tileMapSize.width;
      height = tileMapSize.height;
      this.buffer = makeBuffer(width * tileSize.width, height * tileSize.height, 'div');
      ctx = this.buffer.getContext('2d');
      ctx.translate(0, this.buffer.height);
      binSize = spatialHash.binSize;
      modWidth = Math.floor(binSize.width / tileSize.width);
      modHeight = Math.floor(binSize.height / tileSize.height);
      chunkWidth = modWidth * tileSize.width;
      chunkHeight = modHeight * tileSize.height;
      ctxsArray = [];
      results = [];
      for (y = i = 0, ref = height; 0 <= ref ? i < ref : i > ref; y = 0 <= ref ? ++i : --i) {
        results.push((function() {
          var j, ref1, results1;
          results1 = [];
          for (x = j = 0, ref1 = width; 0 <= ref1 ? j < ref1 : j > ref1; x = 0 <= ref1 ? ++j : --j) {
            chunkX = Math.floor(x / modWidth);
            if (!ctxsArray[chunkX]) {
              ctxsArray[chunkX] = [];
            }
            chunkY = Math.floor(y / modHeight);
            ctxs = ctxsArray[chunkX][chunkY];
            if (!ctxs) {
              bgBuffer = makeBuffer(chunkWidth, chunkHeight);
              fgBuffer = makeBuffer(chunkWidth + 2 * tileSize.width, chunkHeight);
              bgSprite = new Tile({
                buffer: bgBuffer,
                spatialHash: spatialHash,
                order: 0
              });
              fgSprite = new Tile({
                buffer: fgBuffer,
                spatialHash: spatialHash,
                order: 0
              });
              bgSprite.setAnchorPoint(new cc.Point(0, 1));
              fgSprite.setAnchorPoint(new cc.Point(0, 1));
              bgSprite.setPosition(new cc.Point(chunkX * chunkWidth, this.buffer.height - chunkY * chunkHeight));
              fgSprite.setPosition(new cc.Point(chunkX * chunkWidth, chunkY * chunkHeight - this.buffer.height));
              parentSprite.addChild(bgSprite, 0);
              parentSprite.addChild(fgSprite, 1);
              spatialHash.addNode(bgSprite);
              spatialHash.addNode(fgSprite);
              bgSprite = new Tile({
                buffer: bgBuffer,
                spatialHash: spatialHash,
                order: 0
              });
              fgSprite = new Tile({
                buffer: fgBuffer,
                spatialHash: spatialHash,
                order: 0
              });
              bgSprite.setAnchorPoint(new cc.Point(0, 1));
              fgSprite.setAnchorPoint(new cc.Point(0, 1));
              bgSprite.setPosition(new cc.Point(chunkX * chunkWidth + this.buffer.width, this.buffer.height - chunkY * chunkHeight));
              fgSprite.setPosition(new cc.Point(chunkX * chunkWidth + this.buffer.width, chunkY * chunkHeight - this.buffer.height));
              parentSprite.addChild(bgSprite, 0);
              parentSprite.addChild(fgSprite, 1);
              spatialHash.addNode(bgSprite);
              spatialHash.addNode(fgSprite);
              ctxs = ctxsArray[chunkX][chunkY] = {
                bg: bgBuffer.getContext('2d'),
                fg: fgBuffer.getContext('2d')
              };
            }
            spriteFrames = tileSpriteFrameFunction(x, y, tileMap);
            results1.push((function() {
              var k, len, results2;
              results2 = [];
              for (k = 0, len = spriteFrames.length; k < len; k++) {
                spriteFrame = spriteFrames[k];
                if (spriteFrame != null) {
                  spriteFrameRect = spriteFrame.getRect();
                  spriteFrameOffset = spriteFrame.getOffset();
                  ctxs.bg.drawImage(spriteFrame.getTexture(), spriteFrameRect.origin.x, spriteFrameRect.origin.y, spriteFrameRect.size.width, spriteFrameRect.size.height, (x % modWidth) * tileSize.width + spriteFrameOffset.x, (y % modHeight) * tileSize.height + spriteFrameOffset.y, spriteFrameRect.size.width, spriteFrameRect.size.height);
                  results2.push(ctx.drawImage(spriteFrame.getTexture(), spriteFrameRect.origin.x, spriteFrameRect.origin.y, spriteFrameRect.size.width, spriteFrameRect.size.height, x * tileSize.width + spriteFrameOffset.x, y * tileSize.height - this.buffer.height + spriteFrameOffset.y, spriteFrameRect.size.width, spriteFrameRect.size.height));
                } else {
                  results2.push(void 0);
                }
              }
              return results2;
            }).call(this));
          }
          return results1;
        }).call(this));
      }
      return results;
    }
  };

}).call(this);
