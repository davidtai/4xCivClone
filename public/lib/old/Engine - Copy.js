// Generated by CoffeeScript 1.3.1
(function() {
  var Actor, ControllableSprite, Engine, SmartTile, SmartTileLayer, actorId, animationCache, counts, h, i, sharedSpriteFrameCache, sharedSpriteSheetCache, tileDim, tileMap, w, x, y, _i, _j, _k, _l, _m, _n, _o, _p, _q,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  this.Math.cbrt = function(x) {
    var sign;
    if (x === 0) {
      return 0;
    } else {
      sign = x > 0 ? 1 : -1;
      return sign * Math.pow(Math.abs(x), 1 / 3);
    }
  };

  animationCache = cc.AnimationCache.getInstance();

  sharedSpriteFrameCache = cc.SpriteFrameCache.getInstance();

  sharedSpriteSheetCache = cc.SpriteSheetJson.getInstance();

  tileMap = [];

  for (x = _i = 0; _i < 100; x = ++_i) {
    tileMap[y] = [];
    for (y = _j = 0; _j < 100; y = ++_j) {
      tileMap[x][y] = Math.floor(Math.random() * 4);
    }
  }

  counts = [];

  for (i = _k = 1; _k < 6; i = ++_k) {
    for (x = _l = 1; _l < 99; x = ++_l) {
      counts[x] = [];
      for (y = _m = 1; _m < 99; y = ++_m) {
        counts[x][y] = 0;
        for (w = _n = -1; _n < 2; w = ++_n) {
          for (h = _o = -1; _o < 2; h = ++_o) {
            if (tileMap[x + w][y + h] === 1 || tileMap[x + w][y + h] === 2) {
              counts[x][y]++;
            }
          }
        }
      }
    }
    for (x = _p = 1; _p < 99; x = ++_p) {
      for (y = _q = 1; _q < 99; y = ++_q) {
        tileMap[x][y] = counts[x][y] >= 5 ? 2 : counts[x][y] >= 4 ? 3 : 0;
      }
    }
  }

  tileMap.reverse();

  tileDim = new cc.Size(40, 40);

  SmartTile = (function() {

    SmartTile.name = 'SmartTile';

    function SmartTile(tile, x, y, left, up, right, down) {
      this.tile = tile;
      this.x = x;
      this.y = y;
      this.actors = {};
      this.setLeft(left);
      this.setUp(up);
      this.setRight(right);
      this.setDown(down);
    }

    SmartTile.prototype.setLeft = function(tile) {
      if (tile != null) {
        this.left = tile;
        return tile.right = this;
      }
    };

    SmartTile.prototype.setUp = function(tile) {
      if (tile != null) {
        this.up = tile;
        return tile.down = this;
      }
    };

    SmartTile.prototype.setRight = function(tile) {
      if (tile != null) {
        this.right = tile;
        return tile.left = this;
      }
    };

    SmartTile.prototype.setDown = function(tile) {
      if (tile != null) {
        this.down = tile;
        return tile.up = this;
      }
    };

    return SmartTile;

  })();

  SmartTileLayer = (function(_super) {

    __extends(SmartTileLayer, _super);

    SmartTileLayer.name = 'SmartTileLayer';

    function SmartTileLayer() {
      return SmartTileLayer.__super__.constructor.apply(this, arguments);
    }

    SmartTileLayer.prototype.ctor = function(fileImage, w, h, tileMap) {
      this.w = w;
      this.h = h;
      this.tileMap = tileMap;
      this.size = new cc.Size(this.tileMap.length, this.tileMap[0] != null ? this.tileMap[0].length : 1);
      this.init(fileImage, this.size.x * this.size.y);
      return this.loadTiles(tileMap);
    };

    SmartTileLayer.prototype.loadTiles = function() {
      var that;
      this.smartTiles = [];
      this.visibleSmartTiles = [];
      that = this;
      return this.tileMap.map(function(tileIds, y) {
        that.smartTiles[y] = [];
        return tileIds.map(function(tileId, x) {
          var smartTile, smartTileForYMinus1, tile;
          tile = that.getTile(x, y);
          if (tile != null) {
            that.addChild(tile);
            smartTileForYMinus1 = that.smartTiles[y - 1];
            smartTile = new SmartTile(tile, x, y, that.smartTiles[y][x - 1], smartTileForYMinus1 != null ? smartTileForYMinus1[x] : null);
            that.smartTiles[y][x] = smartTile;
            if (tile.isVisible()) {
              that.visibleSmartTiles.push(smartTile);
              return smartTile.marked = true;
            }
          }
        });
      });
    };

    SmartTileLayer.prototype.getTile = function(x, y) {
      var position, tile, tileId, tileIdAbove;
      tileId = this.tileMap[y][x];
      tileIdAbove = this.tileMap[y + 1] != null ? this.tileMap[y + 1][x] : tileId;
      switch (tileId) {
        case 0:
          tile = cc.Sprite.createWithSpriteFrameName("TempBackground");
          break;
        case 1:
          tile = cc.Sprite.createWithSpriteFrameName("TempBox");
          break;
        case 2:
          switch (tileIdAbove) {
            case 2:
              tile = cc.Sprite.createWithSpriteFrameName("TempDirt");
              break;
            default:
              tile = cc.Sprite.createWithSpriteFrameName("TempDirtWalkable");
          }
          break;
        case 3:
          switch (tileIdAbove) {
            case 0:
            case 1:
              tile = cc.Sprite.createWithSpriteFrameName("TempBackDirtWalkable");
              break;
            default:
              tile = cc.Sprite.createWithSpriteFrameName("TempBackDirt");
          }
          break;
        default:
          return null;
      }
      tile.setAnchorPoint(new cc.Point(0, 0));
      position = new cc.Point(tileDim.w * x, tileDim.h * y);
      tile.setPosition(position);
      if (position.x > config.screen.width + tileDim.w || position.x < -tileDim.w || position.y > config.screen.height + tileDim.h || position.y < -tileDim.h) {
        tile.setVisible(false);
      }
      return tile;
    };

    SmartTileLayer.prototype.getOverlappedSmartTiles = function(x, y, w, h) {
      var i, j, overlappedSmartTiles, smartTiles, _r, _ref, _ref1, _s;
      overlappedSmartTiles = [];
      for (j = _r = y, _ref = y + h; y <= _ref ? _r < _ref : _r > _ref; j = y <= _ref ? ++_r : --_r) {
        smartTiles = this.smartTiles[j];
        if (smartTiles != null) {
          for (i = _s = x, _ref1 = x + w; x <= _ref1 ? _s < _ref1 : _s > _ref1; i = x <= _ref1 ? ++_s : --_s) {
            if (smartTiles[i] != null) {
              overlappedSmartTiles.push(smartTiles[i]);
            }
          }
        }
      }
      return overlappedSmartTiles;
    };

    SmartTileLayer.prototype.update = function(dt, scrollPos) {
      var actors, tile, visibleSmartTile, _len, _len1, _r, _ref, _ref1, _results, _s;
      if (this.visibleSmartTiles && scrollPos) {
        _ref = this.visibleSmartTiles;
        for (_r = 0, _len = _ref.length; _r < _len; _r++) {
          visibleSmartTile = _ref[_r];
          tile = visibleSmartTile.tile;
          actors = visibleSmartTile.actors;
          tile.setVisible(false);
        }
        this.visibleSmartTiles = this.getOverlappedSmartTiles(Math.round(scrollPos.x / 40) - 1, Math.round(scrollPos.y / 40) - 1, Math.round(config.screen.width / 40) + 1, Math.round(config.screen.height / 40) + 1);
        _ref1 = this.visibleSmartTiles;
        _results = [];
        for (_s = 0, _len1 = _ref1.length; _s < _len1; _s++) {
          visibleSmartTile = _ref1[_s];
          tile = visibleSmartTile.tile;
          actors = visibleSmartTile.actors;
          _results.push(tile.setVisible(true));
        }
        return _results;
      }
    };

    return SmartTileLayer;

  })(cc.SpriteBatchNode);

  actorId = 0;

  Actor = (function(_super) {
    var currentSmartTile;

    __extends(Actor, _super);

    Actor.name = 'Actor';

    function Actor() {
      return Actor.__super__.constructor.apply(this, arguments);
    }

    Actor.prototype.velocity = 80;

    Actor.prototype.moveDelta = 0;

    Actor.prototype.addMoveDelta = .5;

    Actor.prototype.keyMap = null;

    Actor.prototype.animations = null;

    Actor.prototype.moving = false;

    Actor.prototype.deltaPos = null;

    currentSmartTile = null;

    Actor.prototype.ctor = function(smartTileLayer) {
      var smartTiles;
      this.smartTileLayer = smartTileLayer;
      this.id = actorId++;
      this.init();
      y = Math.floor(this._position.y / 40);
      smartTiles = this.smartTileLayer.smartTiles[y];
      if (smartTiles != null) {
        x = Math.floor(this._position.x / 40);
        this.currentSmartTile = smartTiles[x];
        this.currentSmartTile.actors[this.id] = this;
        return this.setVisible(this.currentSmartTile.tile.isVisible());
      }
    };

    Actor.prototype.update = function(dt) {
      var position, smartTile, smartTiles;
      if (this.myUpdate != null) {
        this.myUpdate(dt);
      }
      position = this._position;
      y = Math.floor(position.y / 40);
      smartTiles = this.smartTileLayer.smartTiles[y];
      if (smartTiles != null) {
        x = Math.floor(position.x / 40);
        smartTile = smartTiles[x];
        if ((smartTile != null) && smartTile !== this.currentSmartTile) {
          if (this.currentSmartTile) {
            delete this.currentSmartTile.actors[this.id];
          }
          this.currentSmartTile = smartTile;
          this.currentSmartTile.actors[this.id] = this;
        }
      }
      if (this.currentSmartTile) {
        return this.setVisible(this.currentSmartTile.tile.isVisible());
      }
    };

    Actor.prototype.handleMove = function(dt) {
      var deltaX, velocity;
      velocity = this.velocity;
      if (!this.isFlippedX()) {
        velocity = -velocity;
      }
      if (dt >= this.moveDelta) {
        this.deltaPos.x += this.moveDelta * velocity;
        deltaX = Math.floor(this.deltaPos.x);
        this._position.x += deltaX;
        this.deltaPos.x -= deltaX;
        return this.moveDelta = 0;
      } else {
        this.deltaPos.x += dt * velocity;
        deltaX = Math.floor(this.deltaPos.x);
        this._position.x += deltaX;
        this.deltaPos.x -= deltaX;
        return this.moveDelta -= dt;
      }
    };

    return Actor;

  })(cc.Sprite);

  ControllableSprite = (function(_super) {

    __extends(ControllableSprite, _super);

    ControllableSprite.name = 'ControllableSprite';

    function ControllableSprite() {
      return ControllableSprite.__super__.constructor.apply(this, arguments);
    }

    ControllableSprite.prototype.ctor = function(smartTileLayer) {
      var animations, readyAnimation, stillAnimation, walkAnimation;
      ControllableSprite.__super__.ctor.call(this, smartTileLayer);
      stillAnimation = animationCache.getAnimation("VanguardStill");
      readyAnimation = animationCache.getAnimation("VanguardReady");
      walkAnimation = animationCache.getAnimation("VanguardWalk");
      animations = {};
      this.animations = animations;
      animations.still = cc.Animate.create(stillAnimation);
      animations.ready = cc.Animate.create(readyAnimation);
      animations.walk = cc.RepeatForever.create(cc.Animate.create(walkAnimation));
      this.runAction(animations.still);
      this.keyMap = {};
      this.deltaPos = new cc.Point(0, 0);
      return this.setAnchorPoint(new cc.Point(0.5, 0));
    };

    ControllableSprite.prototype.myUpdate = function(dt) {
      if (this.keyMap[cc.KEY.left]) {
        this.setFlipX(false);
        this.moveDelta = this.addMoveDelta;
      } else if (this.keyMap[cc.KEY.right]) {
        this.setFlipX(true);
        this.moveDelta = this.addMoveDelta;
      } else if (this.moving) {
        this.stopAllActions();
        this.runAction(this.animations.still);
        this.moving = false;
      }
      if (this.moveDelta > 0) {
        return this.handleMove(dt);
      }
    };

    ControllableSprite.prototype.handleKeyUp = function(e) {
      this.keyMap[e] = false;
      if (e === cc.KEY.left || e === cc.KEY.right) {
        return this.moveDelta = 0;
      }
    };

    ControllableSprite.prototype.handleKeyDown = function(e) {
      if (e === cc.KEY.left && !this.keyMap[e]) {
        this.stopAllActions();
        this.runAction(this.animations.walk);
        this.keyMap[e] = true;
        return this.moving = true;
      } else if (e === cc.KEY.right && !this.keyMap[e]) {
        this.stopAllActions();
        this.runAction(this.animations.walk);
        this.keyMap[e] = true;
        return this.moving = true;
      }
    };

    return ControllableSprite;

  })(Actor);

  Engine = (function(_super) {

    __extends(Engine, _super);

    Engine.name = 'Engine';

    function Engine() {
      return Engine.__super__.constructor.apply(this, arguments);
    }

    Engine.prototype.sprite = null;

    Engine.prototype.sprites = null;

    Engine.prototype.scroll = null;

    Engine.prototype.init = function() {
      var bug, bugWalk, i, layer1, lazyLayer, spriteSize, windowSize, _r;
      windowSize = cc.Director.getInstance().getWinSize();
      windowSize.width = windowSize.width / config.screen.scale;
      windowSize.height = windowSize.height / config.screen.scale;
      layer1 = cc.LayerColor.create(new cc.Color4B(0, 0, 0, 255), config.screen.width, config.screen.height);
      layer1.setPosition(Math.floor((windowSize.width - config.screen.width) / 2), Math.floor((windowSize.height - config.screen.height) / 2));
      this.scroll = cc.Node.create();
      layer1.addChild(this.scroll, 1);
      this.smartTileLayer = new SmartTileLayer(sharedSpriteSheetCache.getSpriteSheet("MapTiles").Source, tileDim.w, tileDim.h, tileMap);
      this.scroll.addChild(this.smartTileLayer);
      this.sprite = new ControllableSprite(this.smartTileLayer);
      this.scroll.addChild(this.sprite);
      spriteSize = this.sprite.getContentSize();
      this.sprite.setPosition(new cc.Point(160, 160));
      this.addChild(layer1);
      this.setTouchEnabled(true);
      this.setKeyboardEnabled(true);
      lazyLayer = new cc.LazyLayer();
      lazyLayer.addChild(cc.LayerColor.create(new cc.Color4B(0, 0, 0, 255), windowSize.width, windowSize.height));
      this.addChild(lazyLayer);
      this.sprites = [];
      for (i = _r = 0; _r < 99; i = ++_r) {
        bug = new Actor(this.smartTileLayer);
        bugWalk = cc.RepeatForever.create(cc.Animate.create(animationCache.getAnimation("WorkerBugWalk")));
        bug.runAction(bugWalk);
        bug.setPosition(new cc.Point(Math.floor(Math.random() * 4000), Math.floor(Math.random() * 4000)));
        bug.setAnchorPoint(new cc.Point(0.5, 0));
        this.scroll.addChild(bug);
        this.sprites.push(bug);
      }
      return true;
    };

    Engine.prototype.onKeyDown = function(e) {
      return this.sprite.handleKeyDown(e);
    };

    Engine.prototype.onKeyUp = function(e) {
      return this.sprite.handleKeyUp(e);
    };

    Engine.prototype.update = function(dt) {
      var scrollPos, sprite, spritePos, z, _len, _r, _ref, _results;
      if (this.sprite.moving) {
        this.sprite.update(dt);
        this.updateSprite(this.sprite);
        scrollPos = this.scroll.getPosition();
        spritePos = this.sprite.getPosition();
        spritePos.x += this.sprite.isFlippedX() ? config.screen.cameraOffset : -config.screen.cameraOffset;
        spritePos.x += scrollPos.x - config.screen.centerX;
        spritePos.y += scrollPos.y - config.screen.centerY;
        if (spritePos.x !== 0 || spritePos.y !== 0) {
          scrollPos.x -= Math.floor(Math.cbrt(spritePos.x));
          scrollPos.y -= Math.floor(Math.cbrt(spritePos.y));
          this.scroll.setPosition(scrollPos);
          scrollPos.x = -scrollPos.x;
          scrollPos.y = -scrollPos.y;
          this.smartTileLayer.update(dt, scrollPos);
        }
      }
      _ref = this.sprites;
      _results = [];
      for (_r = 0, _len = _ref.length; _r < _len; _r++) {
        sprite = _ref[_r];
        sprite.update(dt);
        z = sprite.getPosition();
        z.x -= .3;
        sprite.setPosition(z);
        _results.push(this.updateSprite(sprite));
      }
      return _results;
    };

    Engine.prototype.updateSprite = function(sprite) {
      var scrollPos, spritePos, tileId, tileIds;
      scrollPos = this.scroll.getPosition();
      spritePos = sprite.getPosition();
      y = Math.floor(spritePos.y / tileDim.h);
      tileIds = tileMap[y];
      if (tileIds != null) {
        x = Math.floor(spritePos.x / tileDim.w);
        tileId = tileIds[x];
        if (tileId === 1 || tileId === 2) {
          spritePos.y = (y + 1) * tileDim.h;
          return sprite.setPosition(spritePos);
        } else if ((tileId === 0 || tileId === 3) && tileMap[y - 1] && tileMap[y - 1][x] === 0) {
          spritePos.y = (y - 1) * tileDim.h;
          return sprite.setPosition(spritePos);
        }
      }
    };

    return Engine;

  })(cc.Layer);

  this.engine = cc.Scene.extend({
    onEnter: function() {
      var layer;
      this._super();
      layer = new Engine();
      $(document).keydown(function(e) {
        return layer.onKeyDown(e.which);
      });
      $(document).keyup(function(e) {
        return layer.onKeyUp(e.which);
      });
      layer.init();
      layer.scheduleUpdate();
      layer.setScale(config.screen.scale, config.screen.scale);
      return this.addChild(layer);
    }
  });

}).call(this);
