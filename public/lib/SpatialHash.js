// Generated by CoffeeScript 1.3.1
(function() {
  var NodeSpatialHash, SpatialHash, SpatialHashBin, spatialId;

  SpatialHashBin = (function() {

    SpatialHashBin.name = 'SpatialHashBin';

    function SpatialHashBin(active, nodes) {
      this.nodes = nodes;
      if (!(nodes != null)) {
        this.nodes = {};
      }
      this.active = active !== false && (active != null);
    }

    SpatialHashBin.prototype.add = function(id, node) {
      this.nodes[id] = node;
      return this;
    };

    SpatialHashBin.prototype.remove = function(id) {
      return this.nodes[id] = null;
    };

    return SpatialHashBin;

  })();

  spatialId = 0;

  this.SpatialHash = SpatialHash = (function() {

    SpatialHash.name = 'SpatialHash';

    function SpatialHash(options) {
      var x, y, _i, _j, _ref, _ref1;
      this.options = options;
      this.binSize = this.options.binSize;
      this.spaceSize = this.options.spaceSize;
      this.border = this.options.border;
      this.border = this.border > 0 ? this.border : 0;
      this.gridSize = new cc.Size(Math.ceil(this.spaceSize.width / this.binSize.width), Math.ceil(this.spaceSize.height / this.binSize.height));
      this.grid = [];
      this.activeBins = [];
      for (x = _i = 0, _ref = this.gridSize.width; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        this.grid[x] = [];
        for (y = _j = 0, _ref1 = this.gridSize.height; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
          this.grid[x][y] = new SpatialHashBin();
        }
      }
    }

    SpatialHash.prototype.worldToGrid = function(position) {
      return new cc.Point(Math.floor(position.x / this.binSize.width), Math.floor(position.y / this.binSize.height));
    };

    SpatialHash.prototype.isGridPositionInGrid = function(position) {
      return position.x >= 0 && position.y >= 0 && position.x < this.gridSize.width && position.y < this.gridSize.height;
    };

    SpatialHash.prototype.getBinInGrid = function(x, y) {
      var bins;
      bins = this.grid[x];
      if (bins) {
        return bins[y];
      } else {
        return null;
      }
    };

    SpatialHash.prototype.getBin = function(position) {
      var binPosition;
      binPosition = this.worldToGrid(position);
      if (this.isGridPositionInGrid(binPosition)) {
        return this.getBinInGrid(binPosition.x, binPosition.y);
      }
    };

    SpatialHash.prototype.addNode = function(node) {
      var bin;
      if (!(node.__spatialId != null)) {
        node.__spatialId = spatialId++;
      }
      bin = this.getBin(node.getPosition());
      return this.insertNode(node, bin);
    };

    SpatialHash.prototype.insertNode = function(node, bin) {
      node.__spatialBin = bin;
      if (bin != null) {
        bin.add(node.__spatialId, node);
      }
      return bin;
    };

    SpatialHash.prototype.updateNode = function(node) {
      if ((node.__spatialId != null) && (node.__spatialBin != null)) {
        node.__spatialBin.remove(node.__spatialId);
      }
      return this.addNode(node);
    };

    SpatialHash.prototype.getBinFromNode = function(node) {
      return node.__spatialBin;
    };

    SpatialHash.prototype.setActiveBins = function(boundingRect) {
      var bin, x, x1, x2, y, y1, y2, _i, _j, _k, _len, _ref;
      _ref = this.activeBins;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        bin = _ref[_i];
        bin.active = false;
      }
      this.activeBins.length = 0;
      x1 = Math.max(Math.floor((boundingRect.origin.x - this.border) / this.binSize.width), 0);
      y1 = Math.max(Math.floor((boundingRect.origin.y - this.border) / this.binSize.height), 0);
      x2 = Math.min(Math.ceil((boundingRect.size.width + boundingRect.origin.x + this.border) / this.binSize.width), this.gridSize.width);
      y2 = Math.min(Math.ceil((boundingRect.size.height + boundingRect.origin.y + this.border) / this.binSize.height), this.gridSize.height);
      for (x = _j = x1; x1 <= x2 ? _j < x2 : _j > x2; x = x1 <= x2 ? ++_j : --_j) {
        for (y = _k = y1; y1 <= y2 ? _k < y2 : _k > y2; y = y1 <= y2 ? ++_k : --_k) {
          bin = this.getBinInGrid(x, y);
          if (bin != null) {
            this.activeBins.push(bin);
            bin.active = true;
          }
        }
      }
      return console.log("ActiveBins:" + this.activeBins.length);
    };

    return SpatialHash;

  })();

  this.NodeSpatialHash = NodeSpatialHash = (function() {

    NodeSpatialHash.name = 'NodeSpatialHash';

    function NodeSpatialHash() {}

    NodeSpatialHash.prototype.constuctor = function(options) {
      var node, x, y, _i, _ref, _results;
      this.options = options;
      this.tileSize = this.options.tileSize;
      this.tileMapSize = this.options.tileMapSize;
      this.parentNode = this.options.parentNode;
      this.border = this.options.border;
      this.border = this.border > 0 ? this.border : 0;
      this.gridSize = new cc.Size(Math.ceil(this.tileMapSize.width / this.tileSize.width), Math.ceil(this.tileMapSize.height / this.tileSize.height));
      this.grid = [];
      this.activeNodes = [];
      _results = [];
      for (x = _i = 0, _ref = this.gridSize.width; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        this.grid[x] = [];
        _results.push((function() {
          var _j, _ref1, _results1;
          _results1 = [];
          for (y = _j = 0, _ref1 = this.gridSize.height; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
            node = new cc.Node();
            node.setPosition(new cc.Point(x * tileSize.width, y * tileSize.height));
            node.setVisible(false);
            _results1.push(this.grid[x][y] = node);
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    NodeSpatialHash.prototype.hash = function(position) {
      return new cc.Point(Math.floor(position.x / this.tileSize.width), Math.floor(position.y / this.tileSize.height));
    };

    NodeSpatialHash.prototype.updateNode = function(node, z) {
      var parent, position, x1, x2, y1, y2;
      parent = node.getParent();
      if (parent != null) {
        parent.removeChild(node, false);
      }
      position = this.hash(node.getPosition());
      this.grid[position.x][position.y].addChild(node, z);
      x1 = Math.max(Math.floor((boundingRect.origin.x - this.border) / this.tileSize.width), 0);
      y1 = Math.max(Math.floor((boundingRect.origin.y - this.border) / this.tileSize.height), 0);
      x2 = Math.min(Math.ceil((boundingRect.size.width + boundingRect.origin.x + this.border) / this.tileSize.width), this.gridSize.width);
      return y2 = Math.min(Math.ceil((boundingRect.size.height + boundingRect.origin.y + this.border) / this.tileSize.height), this.gridSize.height);
    };

    NodeSpatialHash.prototype.setVisibleNodes = function(boundingRect) {
      var node, x, y, _i, _j, _len, _ref, _results;
      _ref = this.activeNodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        node.setVisible(false);
      }
      _results = [];
      for (x = _j = x1; x1 <= x2 ? _j < x2 : _j > x2; x = x1 <= x2 ? ++_j : --_j) {
        _results.push((function() {
          var _k, _results1;
          _results1 = [];
          for (y = _k = y1; y1 <= y2 ? _k < y2 : _k > y2; y = y1 <= y2 ? ++_k : --_k) {
            node = grid[x][y];
            node.setVisible(true);
            this.activeNodes.push(node);
            _results1.push(console.log("ActiveBins:" + this.activeNodes.length));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    return NodeSpatialHash;

  })();

}).call(this);
