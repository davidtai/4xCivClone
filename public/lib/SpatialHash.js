// Generated by CoffeeScript 1.10.0
(function() {
  var NodeSpatialHash, SpatialHash, SpatialHashBin, spatialId;

  SpatialHashBin = (function() {
    function SpatialHashBin(active, nodes1) {
      this.nodes = nodes1;
      if (typeof nodes === "undefined" || nodes === null) {
        this.nodes = {};
      }
      this.active = active !== false && (active != null);
    }

    SpatialHashBin.prototype.add = function(id, node) {
      this.nodes[id] = node;
      return this;
    };

    SpatialHashBin.prototype.remove = function(id) {
      return this.nodes[id] = null;
    };

    return SpatialHashBin;

  })();

  spatialId = 0;

  this.SpatialHash = SpatialHash = (function() {
    function SpatialHash(options) {
      var i, j, ref, ref1, x, y;
      if (options == null) {
        options = this.options;
      }
      this.binSize = this.options.binSize;
      this.spaceSize = this.options.spaceSize;
      this.border = this.options.border;
      this.border = this.border > 0 ? this.border : 0;
      this.gridSize = new cc.Size(Math.ceil(this.spaceSize.width / this.binSize.width), Math.ceil(this.spaceSize.height / this.binSize.height));
      this.grid = [];
      this.activeBins = [];
      for (x = i = 0, ref = this.gridSize.width; 0 <= ref ? i < ref : i > ref; x = 0 <= ref ? ++i : --i) {
        this.grid[x] = [];
        for (y = j = 0, ref1 = this.gridSize.height; 0 <= ref1 ? j < ref1 : j > ref1; y = 0 <= ref1 ? ++j : --j) {
          this.grid[x][y] = new SpatialHashBin();
        }
      }
    }

    SpatialHash.prototype.worldToGrid = function(position) {
      return new cc.Point(Math.floor(position.x / this.binSize.width), Math.floor(position.y / this.binSize.height));
    };

    SpatialHash.prototype.isGridPositionInGrid = function(position) {
      return position.x >= 0 && position.y >= 0 && position.x < this.gridSize.width && position.y < this.gridSize.height;
    };

    SpatialHash.prototype.getBinInGrid = function(x, y) {
      var bins;
      bins = this.grid[x];
      if (bins) {
        return bins[y];
      } else {
        return null;
      }
    };

    SpatialHash.prototype.getBin = function(position) {
      var binPosition;
      binPosition = this.worldToGrid(position);
      if (this.isGridPositionInGrid(binPosition)) {
        return this.getBinInGrid(binPosition.x, binPosition.y);
      }
    };

    SpatialHash.prototype.addNode = function(node) {
      var bin;
      if (node.__spatialId == null) {
        node.__spatialId = spatialId++;
      }
      bin = this.getBin(node.getPosition());
      return this.insertNode(node, bin);
    };

    SpatialHash.prototype.insertNode = function(node, bin) {
      node.__spatialBin = bin;
      if (bin != null) {
        bin.add(node.__spatialId, node);
      }
      return bin;
    };

    SpatialHash.prototype.updateNode = function(node) {
      if ((node.__spatialId != null) && (node.__spatialBin != null)) {
        node.__spatialBin.remove(node.__spatialId);
      }
      return this.addNode(node);
    };

    SpatialHash.prototype.getBinFromNode = function(node) {
      return node.__spatialBin;
    };

    SpatialHash.prototype.setActiveBins = function(boundingRect) {
      var bin, i, j, k, len, ref, ref1, ref2, ref3, ref4, x, x1, x2, y, y1, y2;
      ref = this.activeBins;
      for (i = 0, len = ref.length; i < len; i++) {
        bin = ref[i];
        bin.active = false;
      }
      this.activeBins.length = 0;
      x1 = Math.max(Math.floor((boundingRect.origin.x - this.border) / this.binSize.width), 0);
      y1 = Math.max(Math.floor((boundingRect.origin.y - this.border) / this.binSize.height), 0);
      x2 = Math.min(Math.ceil((boundingRect.size.width + boundingRect.origin.x + this.border) / this.binSize.width), this.gridSize.width);
      y2 = Math.min(Math.ceil((boundingRect.size.height + boundingRect.origin.y + this.border) / this.binSize.height), this.gridSize.height);
      for (x = j = ref1 = x1, ref2 = x2; ref1 <= ref2 ? j < ref2 : j > ref2; x = ref1 <= ref2 ? ++j : --j) {
        for (y = k = ref3 = y1, ref4 = y2; ref3 <= ref4 ? k < ref4 : k > ref4; y = ref3 <= ref4 ? ++k : --k) {
          bin = this.getBinInGrid(x, y);
          if (bin != null) {
            this.activeBins.push(bin);
            bin.active = true;
          }
        }
      }
      return console.log("ActiveBins:" + this.activeBins.length);
    };

    return SpatialHash;

  })();

  this.NodeSpatialHash = NodeSpatialHash = (function() {
    function NodeSpatialHash() {}

    NodeSpatialHash.prototype.constuctor = function(options) {
      var i, node, ref, results, x, y;
      if (options == null) {
        options = this.options;
      }
      this.tileSize = this.options.tileSize;
      this.tileMapSize = this.options.tileMapSize;
      this.parentNode = this.options.parentNode;
      this.border = this.options.border;
      this.border = this.border > 0 ? this.border : 0;
      this.gridSize = new cc.Size(Math.ceil(this.tileMapSize.width / this.tileSize.width), Math.ceil(this.tileMapSize.height / this.tileSize.height));
      this.grid = [];
      this.activeNodes = [];
      results = [];
      for (x = i = 0, ref = this.gridSize.width; 0 <= ref ? i < ref : i > ref; x = 0 <= ref ? ++i : --i) {
        this.grid[x] = [];
        results.push((function() {
          var j, ref1, results1;
          results1 = [];
          for (y = j = 0, ref1 = this.gridSize.height; 0 <= ref1 ? j < ref1 : j > ref1; y = 0 <= ref1 ? ++j : --j) {
            node = new cc.Node();
            node.setPosition(new cc.Point(x * tileSize.width, y * tileSize.height));
            node.setVisible(false);
            results1.push(this.grid[x][y] = node);
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    NodeSpatialHash.prototype.hash = function(position) {
      return new cc.Point(Math.floor(position.x / this.tileSize.width), Math.floor(position.y / this.tileSize.height));
    };

    NodeSpatialHash.prototype.updateNode = function(node, z) {
      var parent, position, x1, x2, y1, y2;
      parent = node.getParent();
      if (parent != null) {
        parent.removeChild(node, false);
      }
      position = this.hash(node.getPosition());
      this.grid[position.x][position.y].addChild(node, z);
      x1 = Math.max(Math.floor((boundingRect.origin.x - this.border) / this.tileSize.width), 0);
      y1 = Math.max(Math.floor((boundingRect.origin.y - this.border) / this.tileSize.height), 0);
      x2 = Math.min(Math.ceil((boundingRect.size.width + boundingRect.origin.x + this.border) / this.tileSize.width), this.gridSize.width);
      return y2 = Math.min(Math.ceil((boundingRect.size.height + boundingRect.origin.y + this.border) / this.tileSize.height), this.gridSize.height);
    };

    NodeSpatialHash.prototype.setVisibleNodes = function(boundingRect) {
      var i, j, len, node, ref, ref1, ref2, results, x, y;
      ref = this.activeNodes;
      for (i = 0, len = ref.length; i < len; i++) {
        node = ref[i];
        node.setVisible(false);
      }
      results = [];
      for (x = j = ref1 = x1, ref2 = x2; ref1 <= ref2 ? j < ref2 : j > ref2; x = ref1 <= ref2 ? ++j : --j) {
        results.push((function() {
          var k, ref3, ref4, results1;
          results1 = [];
          for (y = k = ref3 = y1, ref4 = y2; ref3 <= ref4 ? k < ref4 : k > ref4; y = ref3 <= ref4 ? ++k : --k) {
            node = grid[x][y];
            node.setVisible(true);
            this.activeNodes.push(node);
            results1.push(console.log("ActiveBins:" + this.activeNodes.length));
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    return NodeSpatialHash;

  })();

}).call(this);
