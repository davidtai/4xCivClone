// Generated by CoffeeScript 1.3.1
(function() {
  var Engine, MT, animationCache, global, scale, seed, sharedSpriteFrameCache, sharedSpriteSheetCache, size, split, tileSize, worldSize,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  if (disabledSmoothing) {
    scale = 1;
  } else {
    scale = config.screen.scale;
  }

  split = location.search.replace('?', '').split('&').map(function(val) {
    return val.split('=');
  });

  if (split[0] && split[0].length > 0 && split[0][0] === "seed") {
    seed = parseInt(split[0][1], 10);
  } else {
    seed = new Date().getTime();
  }

  $('body').append("<p>Seed: " + seed + "</p>");

  console.log("SEED:" + seed);

  MT = new MersenneTwister(seed);

  Math.random = function() {
    return MT.random.apply(MT, arguments);
  };

  global = this;

  this.Math.cbrt = function(x) {
    var sign;
    if (x === 0) {
      return 0;
    } else {
      sign = x > 0 ? 1 : -1;
      return sign * Math.pow(Math.abs(x), 1 / 3);
    }
  };

  animationCache = cc.AnimationCache.getInstance();

  sharedSpriteFrameCache = cc.SpriteFrameCache.getInstance();

  sharedSpriteSheetCache = cc.SpriteSheetJson.getInstance();

  size = 128;

  tileSize = new cc.Size(40 * scale, 40 * scale);

  worldSize = new cc.Size(tileSize.width * size, tileSize.height * size);

  this.Engine = Engine = (function(_super) {

    __extends(Engine, _super);

    Engine.name = 'Engine';

    function Engine() {
      return Engine.__super__.constructor.apply(this, arguments);
    }

    Engine.prototype.init = function() {
      var offset, options,
        _this = this;
      cc.renderContext.webkitImageSmoothingEnabled = false;
      cc.renderContext.mozImageSmoothingEnabled = false;
      cc.renderContext.imageSmoothingEnabled = false;
      cc.renderContext.oImageSmoothingEnabled = false;
      this.windowSize = cc.Director.getInstance().getWinSize();
      offset = cc.Node.create();
      offset.setPosition(new cc.Point(0, disabledSmoothing ? config.screen.height * config.screen.scale : void 0));
      offset.setScaleX(config.screen.scale);
      offset.setScaleY(-config.screen.scale);
      options = {
        tileSize: tileSize,
        worldSize: worldSize,
        landPlateCount: 96,
        oceanPlateCount: 2,
        fractionLand: .6,
        fractionSubduction: .3,
        rainfallReductionRate: 3,
        maxTemperature: 100,
        minTemperature: -50
      };
      this.sprites = [];
      this.keyMap = {};
      return Async.series(function() {
        return _this.world = new World(options);
      }, function() {
        _this.scroll = cc.Node.create();
        return offset.addChild(_this.scroll, 1);
      }, function() {
        var lazyLayer;
        _this.world.createSprites(_this.scroll, _this.spatialHash);
        _this.overlay = new Overlay({
          tileSize: tileSize,
          screenSize: _this.windowSize,
          parentSprite: _this.scroll
        });
        _this.addChild(offset);
        _this.setTouchEnabled(true);
        _this.setKeyboardEnabled(true);
        lazyLayer = new cc.LazyLayer();
        lazyLayer.addChild(cc.LayerColor.create(new cc.Color4B(0, 0, 0, 255), _this.windowSize.width, _this.windowSize.height));
        _this.addChild(lazyLayer);
        return _this.ready = true;
      });
    };

    Engine.prototype.onKeyDown = function(e) {
      return this.keyMap[e] = true;
    };

    Engine.prototype.onKeyUp = function(e) {
      return this.keyMap[e] = false;
    };

    Engine.prototype.onTouchesEnded = function(pTouch, pEvent) {};

    Engine.prototype.update = function(dt) {
      var child, children, move, position, _i, _len, _ref;
      if (this.ready) {
        position = this.scroll.getPosition();
        if (this.keyMap[cc.KEY.left]) {
          move = true;
          position.x += Math.floor(400 * dt);
          if (position.x > 0) {
            position.x -= worldSize.width;
          }
        }
        if (this.keyMap[cc.KEY.right]) {
          move = true;
          position.x -= Math.floor(400 * dt);
          if (position.x < -2 * worldSize.width + config.screen.width) {
            position.x += worldSize.width;
          }
        }
        if (this.keyMap[cc.KEY.down]) {
          move = true;
          position.y -= Math.floor(400 * dt);
          if (position.y < -worldSize.height + config.screen.height) {
            position.y = -worldSize.height + config.screen.height;
          }
        }
        if (this.keyMap[cc.KEY.up]) {
          move = true;
          position.y += Math.floor(400 * dt);
          if (position.y > 0) {
            position.y = 0;
          }
        }
        if (move) {
          if (this.spatialHash != null) {
            this.spatialHash.setActiveBins(new cc.Rect(-position.x, -position.y, config.screen.width, config.screen.height));
            _ref = this.scroll.getChildren();
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              child = _ref[_i];
              child.update(dt);
            }
          } else {
            children = this.scroll.getChildren();
            if (-position.x < worldSize.width && !children[0].isVisible()) {
              children[0].setVisible(true);
              children[3].setVisible(true);
            } else if (-position.x >= worldSize.width && children[0].isVisible()) {
              children[0].setVisible(false);
              children[3].setVisible(false);
            }
            if (-position.x >= worldSize.width - config.screen.width && children[1].isVisible()) {
              children[1].setVisible(true);
              children[4].setVisible(true);
            } else if (-position.x < worldSize.width - config.screen.width && !children[1].isVisible()) {
              children[1].setVisible(false);
              children[4].setVisible(false);
            }
          }
          this.scroll.setPosition(position);
          return this.overlay.update(dt);
        }
      }
    };

    return Engine;

  })(cc.Layer);

}).call(this);
