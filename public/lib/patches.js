// Generated by CoffeeScript 1.10.0
(function() {
  var actualSpriteSheetJson, cacheAnimation, cacheChildren, cacheImage, cacheSpriteFrame, hasUpscaled, setSpriteSheet, sharedAnimationCache, sharedSpriteFrameCache, sharedTextureCache, spriteSheetJson, spriteSheets, upscale;

  upscale = function(img, zoom) {
    var a, b, buffer, bufferCtx, g, i, imgData, j, k, r, ref, ref1, ref2, refBuffer, x, y;
    refBuffer = document.createElement('canvas');
    refBuffer.width = img.width;
    refBuffer.height = img.height;
    ref = refBuffer.getContext('2d');
    buffer = document.createElement('canvas');
    buffer.width = img.width * zoom;
    buffer.height = img.height * zoom;
    bufferCtx = buffer.getContext('2d');
    ref.drawImage(img, 0, 0);
    imgData = ref.getImageData(0, 0, img.width, img.height).data;
    for (x = j = 0, ref1 = img.width; 0 <= ref1 ? j < ref1 : j > ref1; x = 0 <= ref1 ? ++j : --j) {
      for (y = k = 0, ref2 = img.height; 0 <= ref2 ? k < ref2 : k > ref2; y = 0 <= ref2 ? ++k : --k) {
        i = (y * img.width + x) * 4;
        r = imgData[i];
        g = imgData[i + 1];
        b = imgData[i + 2];
        a = imgData[i + 3];
        bufferCtx.fillStyle = "rgba(" + r + "," + g + "," + b + "," + (a / 255) + ")";
        bufferCtx.fillRect(x * zoom, y * zoom, zoom, zoom);
      }
    }
    return buffer;
  };

  sharedTextureCache = this.cc.TextureCache.getInstance();

  sharedSpriteFrameCache = this.cc.SpriteFrameCache.getInstance();

  sharedAnimationCache = this.cc.AnimationCache.getInstance();

  cacheSpriteFrame = function(json, name, texture) {
    var frameRect, hotspot, rect, scale, spriteFrame;
    rect = json.Rect;
    if (config.disabledSmoothing) {
      scale = 1;
    } else {
      scale = config.screen.scale;
    }
    frameRect = new cc.Rect(rect.x * scale, rect.y * scale, rect.w * scale, rect.h * scale);
    hotspot = json.Hotspot;
    spriteFrame = cc.SpriteFrame.createWithTexture(texture, frameRect, false, new cc.Point(hotspot.x * scale, hotspot.y * scale), frameRect.size);
    sharedSpriteFrameCache.addSpriteFrame(spriteFrame, name);
    return spriteFrame;
  };

  cacheAnimation = function(json, texture) {
    var animation, id, spriteFrames;
    id = json.Id;
    if (id && json.Sprites) {
      spriteFrames = json.Sprites.map(function(json, i) {
        return cacheSpriteFrame(json, id + parseInt(i, 10), texture);
      });
      animation = cc.Animation.create();
      animation.initWithSpriteFrames(spriteFrames, (json.Rate != null ? json.Rate : 1));
      return sharedAnimationCache.addAnimation(animation, json.Id);
    }
  };

  hasUpscaled = [];

  cacheChildren = function() {
    var animations, statics, texture;
    if (config.screen.scale === 1 || config.disabledSmoothing === true) {
      texture = sharedTextureCache.addImage(this.Source);
    } else if (config.screen.scale !== 1) {
      if (!hasUpscaled[this.Source]) {
        texture = sharedTextureCache.addImage(this.Source);
        texture = upscale(texture, config.screen.scale);
        hasUpscaled[this.Source] = true;
        sharedTextureCache.cacheImage(this.Source + "Upscaled", texture);
      } else {
        texture = sharedTextureCache.addImage(this.Source + "Upscaled");
      }
    }
    if (this.Animations) {
      animations = this.Animations.map(function(json) {
        return cacheAnimation(json, texture);
      });
    }
    if (this.Statics) {
      return statics = this.Statics.map(function(json) {
        return cacheSpriteFrame(json, json.Id, texture);
      });
    }
  };

  cacheImage = function(json, callback) {
    return sharedTextureCache.addImageAsync(json.Source, json, callback);
  };

  spriteSheets = {};

  setSpriteSheet = function(json) {
    if (json.Id && json.Source) {
      spriteSheets[json.Id] = json;
      json.Source = config.assetsFolder + json.Source;
      return cacheImage(json, cacheChildren);
    }
  };

  actualSpriteSheetJson = {
    preloadSpriteJson: function(url) {
      return $.getJSON(url, setSpriteSheet);
    },
    getSpriteSheet: function(id) {
      return spriteSheets[id];
    }
  };

  spriteSheetJson = {
    getInstance: function() {
      return actualSpriteSheetJson;
    }
  };

  this.cc.SpriteSheetJson = spriteSheetJson;

  this.cc.Loader.prototype.preload = function(resources) {
    var key, res, sharedEngine, sharedFileUtils, sharedParser, sharedSpriteSheetJson;
    sharedEngine = cc.AudioEngine.getInstance();
    sharedParser = cc.SAXParser.getInstance();
    sharedFileUtils = cc.FileUtils.getInstance();
    sharedSpriteSheetJson = cc.SpriteSheetJson.getInstance();
    this.loadedResourceCount = 0;
    this.resourceCount = 0;
    for (key in resources) {
      res = resources[key];
      switch (res.type) {
        case "image":
          sharedTextureCache.addImage(res.src);
          break;
        case "sound":
          sharedEngine.preloadSound(res.src);
          break;
        case "plist":
        case "tmx":
        case "fnt":
          sharedParser.preloadPlist(res.src);
          break;
        case "tga":
        case "ccbi":
        case "binary":
          sharedFileUtils.preloadBinaryFileData(res.src);
          break;
        case "face-font":
          this._registerFaceFont(res[i]);
          break;
        case "sprite-json":
          sharedSpriteSheetJson.preloadSpriteJson(res.src);
          break;
        default:
          throw "cocos2d:unknown type : " + res.type;
      }
      this.resourceCount++;
    }
    return this.isLoadedComplete();
  };

  this.cc.Loader.prototype.isLoadedComplete = function() {
    var loaderCache;
    loaderCache = cc.Loader.getInstance();
    if (loaderCache.loadedResourceCount >= loaderCache.resourceCount) {
      if (loaderCache.onload) {
        return loaderCache.timer = setTimeout(loaderCache.onload, 16);
      } else {
        return cc.Assert(0, "cocos2d:no load callback defined");
      }
    } else {
      if (loaderCache.onloading) {
        loaderCache.timer = setTimeout(loaderCache.onloading, 16);
      } else {
        cc.LoaderScene.getInstance().draw();
      }
      return loaderCache.timer = setTimeout(loaderCache.isLoadedComplete, 16);
    }
  };

}).call(this);
