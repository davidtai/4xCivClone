// Generated by CoffeeScript 1.10.0
(function() {
  var ClimateGenerator, GeographicTile, GeographyGenerator, GeologyGenerator, TileGraphic, loadTiles, randomArrayElement, randomOffset, sharedSpriteFrameCache,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  sharedSpriteFrameCache = cc.SpriteFrameCache.getInstance();

  GeographyGenerator = (function() {
    function GeographyGenerator(options) {
      if (options == null) {
        options = this.options;
      }
    }

    GeographyGenerator.prototype.run = function(world) {};

    return GeographyGenerator;

  })();

  GeologyGenerator = (function(superClass) {
    extend(GeologyGenerator, superClass);

    function GeologyGenerator(options) {
      if (options == null) {
        options = this.options;
      }
      $.extend(this, {
        landCount: 1,
        oceanPlateCount: 1,
        fractionSubduction: 0.3,
        fractionLand: 0.3,
        hasEqualLand: true
      }, options);
    }

    GeologyGenerator.prototype.run = function(world) {
      var candidateList, candidateLists, direction, geographicTile, geographicTileMap, i, id, j, k, landCount, m, oceanPlateCount, point, points, randomSlots, randoms, ref, ref1, requiredLandCount, requiredSubductionCount, results, subductionCount, tileMapSize, totalTileCount, x, y;
      tileMapSize = world.tileMapSize;
      geographicTileMap = world.geographicTileMap;
      candidateLists = [];
      randoms = [];
      for (i = k = 0, ref = this.landPlateCount; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        x = Math.floor(tileMapSize.width * Math.random());
        y = Math.floor(tileMapSize.height * Math.random());
        candidateList = candidateLists[i] = [new cc.Point(x, y)];
        randomSlots = Math.random() * 10;
        randomSlots *= randomSlots * randomSlots * randomSlots * randomSlots;
        for (j = m = 0, ref1 = randomSlots; 0 <= ref1 ? m < ref1 : m > ref1; j = 0 <= ref1 ? ++m : --m) {
          randoms.push(i);
        }
      }
      landCount = 0;
      totalTileCount = tileMapSize.width * tileMapSize.height;
      requiredLandCount = totalTileCount * this.fractionLand;
      while (landCount <= requiredLandCount) {
        id = randoms[Math.floor(randoms.length * Math.random())];
        candidateList = candidateLists[id];
        if (candidateList.length > 0) {
          i = Math.floor(candidateList.length * Math.random());
          point = candidateList.splice(i, 1)[0];
          x = point.x;
          y = point.y;
          geographicTile = geographicTileMap[x][y];
          if (!geographicTile.landPlateIds[id]) {
            geographicTile.landPlateIds[id] = true;
            geographicTile.landPlateIds.length++;
            geographicTile.elevation += 1 + Math.sqrt(Math.random() * 1.2);
            points = [];
            if (geographicTile.landPlateIds.length <= 1) {
              landCount++;
              points = [[x - 1, y], [x, y - 1], [x + 1, y], [x, y + 1]];
            } else {
              geographicTile.elevation += Math.sqrt(Math.random() * 2);
              direction = Math.floor(4 * Math.random());
              if (direction === 0) {
                points.push([x - 1, y]);
              } else if (direction === 1) {
                points.push([x, y - 1]);
              } else if (direction === 2) {
                points.push([x + 1, y]);
              } else if (direction === 3) {
                points.push([x, y + 1]);
              }
            }
            this.addToCandidates(candidateList, geographicTileMap, tileMapSize, points);
          }
        }
      }
      oceanPlateCount = this.oceanPlateCount;
      requiredSubductionCount = this.fractionSubduction * totalTileCount;
      candidateList = [];
      while (oceanPlateCount > 0) {
        x = Math.floor(tileMapSize.width * Math.random());
        y = Math.floor(tileMapSize.height * Math.random());
        geographicTile = geographicTileMap[x][y];
        if (geographicTileMap[x][y].elevation === 0) {
          candidateList.push(new cc.Point(x, y));
          oceanPlateCount--;
        }
      }
      subductionCount = 0;
      results = [];
      while (subductionCount <= requiredSubductionCount && candidateList.length > 0) {
        i = Math.floor(candidateList.length * Math.random());
        point = candidateList.splice(i, 1)[0];
        x = point.x;
        y = point.y;
        geographicTile = geographicTileMap[x][y];
        if (geographicTile.subduction === false) {
          if (geographicTile.landPlateIds.length === 0) {
            geographicTile.subduction = true;
            subductionCount += 1;
            results.push(this.addToCandidates(candidateList, geographicTileMap, tileMapSize, [[x - 1, y], [x, y - 1], [x + 1, y], [x, y + 1], [x - 2, y], [x - 1, y - 1], [x, y - 2], [x + 1, y - 1], [x + 2, y], [x + 1, y + 1], [x, y + 2]], 2));
          } else {
            results.push(geographicTile.elevation += Math.sqrt(Math.random() * 2));
          }
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    GeologyGenerator.prototype.addToCandidates = function(candidateList, geographicTileMap, tileMapSize, points, heightTolerance) {
      var k, len, point, results, x, y;
      if (heightTolerance == null) {
        heightTolerance = 1000;
      }
      results = [];
      for (k = 0, len = points.length; k < len; k++) {
        point = points[k];
        x = point[0];
        y = point[1];
        x = (x + tileMapSize.width) % tileMapSize.width;
        if (y >= 0 && y < tileMapSize.height && geographicTileMap[x] && geographicTileMap[x][y].elevation <= heightTolerance) {
          results.push(candidateList.push(new cc.Point(x, (y + tileMapSize.height) % tileMapSize.height)));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    return GeologyGenerator;

  })(GeographyGenerator);

  ClimateGenerator = (function(superClass) {
    extend(ClimateGenerator, superClass);

    function ClimateGenerator(options) {
      if (options == null) {
        options = this.options;
      }
      $.extend(this, {
        minTemperature: -50,
        maxTemperature: 100,
        minRainfall: 0,
        maxRainfall: 100,
        rainfallReductionRate: 4
      }, options);
      this.temperatureRange = this.maxTemperature - this.minTemperature;
      this.rainfallRange = this.maxRainfall - this.minRainfall;
      this.rainfallReductionRateDiagonal = this.rainfallReductionRate * Math.SQRT2;
      this.mountainRainfallReductionRate = this.rainfallReductionRate * 10;
      this.mountainRainfallReductionRateDiagonal = this.rainfallReductionRateDiagonal * 10;
      this.surroundingRainfallReductionRate = this.rainfallReductionRate * 5;
    }

    ClimateGenerator.prototype.run = function(world) {
      var geographicTileMap, halfHeight1, halfHeight2, halfPi, halfPiRatio, k, m, ref, ref1, temperature, tileMapSize, x, y;
      tileMapSize = world.tileMapSize;
      geographicTileMap = world.geographicTileMap;
      halfPi = Math.PI / 2;
      halfHeight1 = tileMapSize.height / 2;
      halfHeight2 = Math.floor(halfHeight1);
      if (halfHeight1 === halfHeight2) {
        halfHeight1 -= 1;
      } else {
        halfHeight1 = halfHeight2;
      }
      halfPiRatio = halfPi / halfHeight2;
      for (x = k = 0, ref = tileMapSize.width; 0 <= ref ? k < ref : k > ref; x = 0 <= ref ? ++k : --k) {
        for (y = m = 0, ref1 = halfHeight1 + 1; 0 <= ref1 ? m < ref1 : m > ref1; y = 0 <= ref1 ? ++m : --m) {
          temperature = this.temperatureRange * Math.cos(halfPiRatio * y) + this.minTemperature;
          geographicTileMap[x][halfHeight1 - y].temperature = temperature;
          geographicTileMap[x][halfHeight2 + y].temperature = temperature;
        }
      }
      return Async.series((function(_this) {
        return function() {
          return _this.hadleyCells(tileMapSize, geographicTileMap, halfHeight1, halfHeight2);
        };
      })(this), (function(_this) {
        return function() {
          return _this.rainfall(tileMapSize, geographicTileMap);
        };
      })(this), (function(_this) {
        return function() {
          return _this.temperatureModeration(tileMapSize, geographicTileMap);
        };
      })(this));
    };

    ClimateGenerator.prototype.hadleyCells = function(tileMapSize, geographicTileMap, halfHeight1, halfHeight2) {
      var degree30, degree60, k, m, n, ref, ref1, ref2, ref3, results, x, y;
      degree30 = Math.floor(Math.sin(Math.PI / 6) * halfHeight2);
      degree60 = Math.floor(Math.sin(Math.PI / 3) * halfHeight2);
      results = [];
      for (x = k = 0, ref = tileMapSize.width; 0 <= ref ? k < ref : k > ref; x = 0 <= ref ? ++k : --k) {
        for (y = m = 0, ref1 = degree30; 0 <= ref1 ? m < ref1 : m > ref1; y = 0 <= ref1 ? ++m : --m) {
          geographicTileMap[x][halfHeight1 - y].windDirection = 9;
          geographicTileMap[x][halfHeight2 + y].windDirection = 3;
        }
        for (y = n = ref2 = degree30, ref3 = degree60; ref2 <= ref3 ? n < ref3 : n > ref3; y = ref2 <= ref3 ? ++n : --n) {
          geographicTileMap[x][halfHeight1 - y].windDirection = 1;
          geographicTileMap[x][halfHeight2 + y].windDirection = 7;
        }
        results.push((function() {
          var o, ref4, ref5, results1;
          results1 = [];
          for (y = o = ref4 = degree60, ref5 = halfHeight1 + 1; ref4 <= ref5 ? o < ref5 : o > ref5; y = ref4 <= ref5 ? ++o : --o) {
            geographicTileMap[x][halfHeight1 - y].windDirection = 9;
            results1.push(geographicTileMap[x][halfHeight2 + y].windDirection = 3);
          }
          return results1;
        })());
      }
      return results;
    };

    ClimateGenerator.prototype.rainfall = function(tileMapSize, geographicTileMap) {
      var aa, candidate, candidateList, geographicTile, i, k, len, m, n, o, p, percentDeviation, q, rainfall, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, results, s, u, v, w, x, y, z;
      candidateList = [];
      for (x = k = 0, ref = tileMapSize.width; 0 <= ref ? k < ref : k > ref; x = 0 <= ref ? ++k : --k) {
        for (y = m = 0, ref1 = tileMapSize.height; 0 <= ref1 ? m < ref1 : m > ref1; y = 0 <= ref1 ? ++m : --m) {
          if (geographicTileMap[x][y].elevation === 0) {
            candidateList.push(new cc.Point(x, y));
          }
        }
      }
      for (n = 0, len = candidateList.length; n < len; n++) {
        candidate = candidateList[n];
        x = candidate.x;
        y = candidate.y;
        rainfall = this.maxRainfall;
        geographicTile = geographicTileMap[x][y];
        i = 1;
        while (rainfall > 0) {
          if (geographicTile == null) {
            break;
          }
          if (geographicTile.elevation > 4) {
            rainfall -= this.mountainRainfallReductionRateDiagonal;
          }
          geographicTile.rainfall = Math.max(rainfall, geographicTile.rainfall);
          if (geographicTile.windDirection === 9) {
            x = (x - 1 + tileMapSize.width) % tileMapSize.width;
            y++;
          } else if (geographicTile.windDirection === 3) {
            x = (x - 1 + tileMapSize.width) % tileMapSize.width;
            y--;
          } else if (geographicTile.windDirection === 1) {
            x = (x + 1) % tileMapSize.width;
            y--;
          } else if (geographicTile.windDirection === 7) {
            x = (x + 1) % tileMapSize.width;
            y++;
          } else {
            throw new Error("this shouldn't happen");
          }
          rainfall -= this.rainfallReductionRateDiagonal;
          geographicTile = geographicTileMap[x][y];
          i++;
        }
        if (geographicTile != null) {
          geographicTile.rainfall = Math.max(rainfall, geographicTile.rainfall);
        }
      }
      results = [];
      for (i = o = 0; o < 2; i = ++o) {
        for (x = p = 0, ref2 = tileMapSize.width; 0 <= ref2 ? p < ref2 : p > ref2; x = 0 <= ref2 ? ++p : --p) {
          for (y = q = 0, ref3 = tileMapSize.height; 0 <= ref3 ? q < ref3 : q > ref3; y = 0 <= ref3 ? ++q : --q) {
            this.diffuseRainfall(tileMapSize, geographicTileMap, x, y);
          }
        }
        for (x = s = ref4 = tileMapSize.width - 1; ref4 <= -1 ? s < -1 : s > -1; x = ref4 <= -1 ? ++s : --s) {
          for (y = u = 0, ref5 = tileMapSize.height; 0 <= ref5 ? u < ref5 : u > ref5; y = 0 <= ref5 ? ++u : --u) {
            this.diffuseRainfall(tileMapSize, geographicTileMap, x, y);
          }
        }
        for (x = v = ref6 = tileMapSize.width - 1; ref6 <= -1 ? v < -1 : v > -1; x = ref6 <= -1 ? ++v : --v) {
          for (y = w = ref7 = tileMapSize.height - 1; ref7 <= -1 ? w < -1 : w > -1; y = ref7 <= -1 ? ++w : --w) {
            this.diffuseRainfall(tileMapSize, geographicTileMap, x, y);
          }
        }
        for (x = z = 0, ref8 = tileMapSize.width; 0 <= ref8 ? z < ref8 : z > ref8; x = 0 <= ref8 ? ++z : --z) {
          for (y = aa = 0, ref9 = tileMapSize.height; 0 <= ref9 ? aa < ref9 : aa > ref9; y = 0 <= ref9 ? ++aa : --aa) {
            this.diffuseRainfall(tileMapSize, geographicTileMap, x, y);
          }
        }
        results.push((function() {
          var ab, ref10, results1;
          results1 = [];
          for (x = ab = 0, ref10 = tileMapSize.width; 0 <= ref10 ? ab < ref10 : ab > ref10; x = 0 <= ref10 ? ++ab : --ab) {
            results1.push((function() {
              var ac, ref11, results2;
              results2 = [];
              for (y = ac = 0, ref11 = tileMapSize.height; 0 <= ref11 ? ac < ref11 : ac > ref11; y = 0 <= ref11 ? ++ac : --ac) {
                geographicTile = geographicTileMap[x][y];
                percentDeviation = Math.random() * .2 + .9;
                geographicTile.rainfall *= percentDeviation;
                percentDeviation = Math.random() * .2 + .9;
                results2.push(geographicTile.temperature *= percentDeviation);
              }
              return results2;
            })());
          }
          return results1;
        })());
      }
      return results;
    };

    ClimateGenerator.prototype.temperatureModeration = function(tileMapSize, geographicTileMap) {
      var k, ref, results, x, y;
      results = [];
      for (x = k = 0, ref = tileMapSize.width; 0 <= ref ? k < ref : k > ref; x = 0 <= ref ? ++k : --k) {
        results.push((function() {
          var m, ref1, results1;
          results1 = [];
          for (y = m = 0, ref1 = tileMapSize.height; 0 <= ref1 ? m < ref1 : m > ref1; y = 0 <= ref1 ? ++m : --m) {
            results1.push(geographicTileMap[x][y].temperature += (geographicTileMap[x][y].rainfall * this.temperatureRange) / 1000 + this.minTemperature / 10);
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    ClimateGenerator.prototype.diffuseRainfall = function(tileMapSize, geographicTileMap, x, y) {
      var geographicTile, referenceRainfall1, referenceRainfall2, referenceRainfall3, referenceRainfall4;
      geographicTile = geographicTileMap[x][y];
      referenceRainfall2 = 0;
      referenceRainfall3 = 0;
      referenceRainfall4 = 0;
      if (geographicTile.elevation <= 4) {
        if (geographicTile.windDirection === 1) {
          referenceRainfall1 = geographicTileMap[(x - 1 + tileMapSize.width) % tileMapSize.width][y].rainfall - this.rainfallReductionRate;
          if (y + 1 < tileMapSize.height) {
            referenceRainfall2 = geographicTileMap[(x - 1 + tileMapSize.width) % tileMapSize.width][y + 1].rainfall - this.rainfallReductionRateDiagonal;
          }
          if (y - 1 > 0) {
            referenceRainfall3 = geographicTileMap[x][y - 1].rainfall - this.surroundingRainfallReductionRate;
          }
          if (y + 1 < tileMapSize.height) {
            referenceRainfall4 = geographicTileMap[x][y + 1].rainfall - this.surroundingRainfallReductionRate;
          }
        } else if (geographicTile.windDirection === 7) {
          referenceRainfall1 = geographicTileMap[(x - 1 + tileMapSize.width) % tileMapSize.width][y].rainfall - this.rainfallReductionRate;
          if (y - 1 > 0) {
            referenceRainfall2 = geographicTileMap[(x - 1 + tileMapSize.width) % tileMapSize.width][y - 1].rainfall - this.rainfallReductionRateDiagonal;
          }
          if (y - 1 > 0) {
            referenceRainfall3 = geographicTileMap[x][y - 1].rainfall - this.surroundingRainfallReductionRate;
          }
          if (y + 1 < tileMapSize.height) {
            referenceRainfall4 = geographicTileMap[x][y + 1].rainfall - this.surroundingRainfallReductionRate;
          }
        } else if (geographicTile.windDirection === 3) {
          referenceRainfall1 = geographicTileMap[(x + 1) % tileMapSize.width][y].rainfall - this.rainfallReductionRate;
          if (y + 1 < tileMapSize.height) {
            referenceRainfall2 = geographicTileMap[(x + 1) % tileMapSize.width][y + 1].rainfall - this.rainfallReductionRateDiagonal;
          }
          if (y - 1 > 0) {
            referenceRainfall3 = geographicTileMap[x][y - 1].rainfall - this.surroundingRainfallReductionRate;
          }
          if (y + 1 < tileMapSize.height) {
            referenceRainfall4 = geographicTileMap[x][y + 1].rainfall - this.surroundingRainfallReductionRate;
          }
        } else if (geographicTile.windDirection === 9) {
          referenceRainfall1 = geographicTileMap[(x + 1) % tileMapSize.width][y].rainfall - this.rainfallReductionRate;
          if (y - 1 > 0) {
            referenceRainfall2 = geographicTileMap[(x + 1) % tileMapSize.width][y - 1].rainfall - this.rainfallReductionRateDiagonal;
          }
          if (y - 1 > 0) {
            referenceRainfall3 = geographicTileMap[x][y - 1].rainfall - this.surroundingRainfallReductionRate;
          }
          if (y + 1 < tileMapSize.height) {
            referenceRainfall4 = geographicTileMap[x][y + 1].rainfall - this.surroundingRainfallReductionRate;
          }
        }
        geographicTile.rainfall = Math.max(referenceRainfall1, referenceRainfall2, referenceRainfall3, referenceRainfall4, geographicTile.rainfall);
        if (isNaN(geographicTile.rainfall)) {
          throw new Error("NAN");
        }
      }
    };

    return ClimateGenerator;

  })(GeographyGenerator);

  GeographicTile = (function() {
    function GeographicTile(options) {
      if (options == null) {
        options = this.options;
      }
      $.extend(this, {
        elevation: 0,
        temperature: 0,
        windDirection: 5,
        rainfall: -1,
        landPlateIds: {
          length: 0
        },
        subduction: false,
        tileGraphic: null,
        tiles: null,
        transitions: null,
        doodads: null
      }, options);
    }

    return GeographicTile;

  })();

  TileGraphic = (function() {
    function TileGraphic(options) {
      if (options == null) {
        options = this.options;
      }
      $.extend(this, {
        spriteFrames5: [],
        spriteFrames8: [],
        spriteFrames7: [],
        spriteFrames4: [],
        spriteFrames1: [],
        spriteFrames2: [],
        spriteFrames3: [],
        spriteFrames6: [],
        spriteFrames9: [],
        hills: []
      }, this.options);
    }

    return TileGraphic;

  })();

  loadTiles = function(name) {
    return {
      spriteFrames5: [sharedSpriteFrameCache.getSpriteFrame(name + "1"), sharedSpriteFrameCache.getSpriteFrame(name + "2"), sharedSpriteFrameCache.getSpriteFrame(name + "3"), sharedSpriteFrameCache.getSpriteFrame(name + "4")],
      spriteFrames8: [sharedSpriteFrameCache.getSpriteFrame(name + "T1"), sharedSpriteFrameCache.getSpriteFrame(name + "T2")],
      spriteFrames7: [sharedSpriteFrameCache.getSpriteFrame(name + "TL1")],
      spriteFrames4: [sharedSpriteFrameCache.getSpriteFrame(name + "L1"), sharedSpriteFrameCache.getSpriteFrame(name + "L2")],
      spriteFrames1: [sharedSpriteFrameCache.getSpriteFrame(name + "BL1")],
      spriteFrames2: [sharedSpriteFrameCache.getSpriteFrame(name + "B1"), sharedSpriteFrameCache.getSpriteFrame(name + "B2")],
      spriteFrames3: [sharedSpriteFrameCache.getSpriteFrame(name + "BR1")],
      spriteFrames6: [sharedSpriteFrameCache.getSpriteFrame(name + "R1"), sharedSpriteFrameCache.getSpriteFrame(name + "R2")],
      spriteFrames9: [sharedSpriteFrameCache.getSpriteFrame(name + "TR1")],
      hills: [sharedSpriteFrameCache.getSpriteFrame(name + "Hill1"), sharedSpriteFrameCache.getSpriteFrame(name + "Hill2"), sharedSpriteFrameCache.getSpriteFrame(name + "Hill3"), sharedSpriteFrameCache.getSpriteFrame(name + "Hill4")]
    };
  };

  randomArrayElement = function(tiles) {
    return tiles[Math.floor(tiles.length * Math.random())];
  };

  randomOffset = function(spriteFrame, tileSize) {
    var rect;
    rect = spriteFrame.getRect();
    return new cc.Point(Math.floor(Math.random() * (tileSize.width - rect.size.width / 3) + rect.size.width / 6), Math.floor(Math.random() * (tileSize.height - rect.size.height / 3) + rect.size.height / 6));
  };

  this.World = (function() {
    function World(options) {
      var generatorOptions, i, j, k, m, ref, ref1;
      if (options == null) {
        options = this.options;
      }
      this.tileSize = options.tileSize;
      this.worldSize = options.worldSize;
      this.tileMapSize = new cc.Size(this.worldSize.width / this.tileSize.width, this.worldSize.height / this.tileSize.height);
      this.geographicTileMap = [];
      for (i = k = 0, ref = this.tileMapSize.width; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        this.geographicTileMap[i] = [];
        for (j = m = 0, ref1 = this.tileMapSize.height; 0 <= ref1 ? m < ref1 : m > ref1; j = 0 <= ref1 ? ++m : --m) {
          this.geographicTileMap[i][j] = new GeographicTile();
        }
      }
      generatorOptions = {
        tileMapSize: this.tileMapSize
      };
      $.extend(generatorOptions, options);
      this.geologyGenerator = new GeologyGenerator(generatorOptions);
      this.climateGenerator = new ClimateGenerator(generatorOptions);
      Async.series((function(_this) {
        return function() {
          return _this.geologyGenerator.run(_this);
        };
      })(this), (function(_this) {
        return function() {
          return _this.climateGenerator.run(_this);
        };
      })(this));
    }

    World.prototype.createSprites = function(layerSprite, spatialHash) {
      var DesertTiles, GrassTiles, LeechedTiles, PlainTiles, PolarTiles, PrairieTiles, TaigaTiles, WaterTiles, b, coldMountain, doodadsSpriteFrameFunction, dryGrassTuft, geographicTile, grassTuft, hut, icyMountain, junglyTree, k, l, leafyTree, m, mountain, n, newPriority, o, pineyTree, priority, r, rain100, rain25, rain50, rain75, rainfall, ref, ref1, ref2, ref3, t, temperature, tilePriority, tileSpriteFrameFunction, transitionSpriteFrameFunction, windNE, windNW, windSE, windSW, x, y;
      WaterTiles = new TileGraphic({
        spriteFrames5: [sharedSpriteFrameCache.getSpriteFrame("Water1")],
        spriteFrames8: [sharedSpriteFrameCache.getSpriteFrame("BeachT1")],
        spriteFrames7: [sharedSpriteFrameCache.getSpriteFrame("BeachTL1")],
        spriteFrames4: [sharedSpriteFrameCache.getSpriteFrame("BeachL1")],
        spriteFrames1: [sharedSpriteFrameCache.getSpriteFrame("BeachBL1")],
        spriteFrames2: [sharedSpriteFrameCache.getSpriteFrame("BeachB1")],
        spriteFrames3: [sharedSpriteFrameCache.getSpriteFrame("BeachBR1")],
        spriteFrames6: [sharedSpriteFrameCache.getSpriteFrame("BeachR1")],
        spriteFrames9: [sharedSpriteFrameCache.getSpriteFrame("BeachTR1")]
      });
      GrassTiles = new TileGraphic(loadTiles("Grassland"));
      LeechedTiles = new TileGraphic(loadTiles("Leeched"));
      PrairieTiles = new TileGraphic(loadTiles("Prairie"));
      DesertTiles = new TileGraphic(loadTiles("Desert"));
      PlainTiles = new TileGraphic(loadTiles("Plain"));
      TaigaTiles = new TileGraphic(loadTiles("Taiga"));
      PolarTiles = new TileGraphic(loadTiles("Polar"));
      tilePriority = [PrairieTiles, GrassTiles, TaigaTiles, DesertTiles, PlainTiles, LeechedTiles, PolarTiles, WaterTiles].reverse();
      grassTuft = sharedSpriteFrameCache.getSpriteFrame("GrassTuft1");
      dryGrassTuft = sharedSpriteFrameCache.getSpriteFrame("GrassTuft2");
      leafyTree = sharedSpriteFrameCache.getSpriteFrame("Tree1");
      pineyTree = sharedSpriteFrameCache.getSpriteFrame("Tree2");
      junglyTree = sharedSpriteFrameCache.getSpriteFrame("Tree3");
      mountain = sharedSpriteFrameCache.getSpriteFrame("Mountain1");
      coldMountain = sharedSpriteFrameCache.getSpriteFrame("Mountain2");
      icyMountain = sharedSpriteFrameCache.getSpriteFrame("Mountain3");
      hut = sharedSpriteFrameCache.getSpriteFrame("Hut1");
      windSW = sharedSpriteFrameCache.getSpriteFrame("SW");
      windSE = sharedSpriteFrameCache.getSpriteFrame("SE");
      windNW = sharedSpriteFrameCache.getSpriteFrame("NW");
      windNE = sharedSpriteFrameCache.getSpriteFrame("NE");
      rain100 = sharedSpriteFrameCache.getSpriteFrame("100");
      rain75 = sharedSpriteFrameCache.getSpriteFrame("75");
      rain50 = sharedSpriteFrameCache.getSpriteFrame("50");
      rain25 = sharedSpriteFrameCache.getSpriteFrame("25");
      for (x = k = 0, ref = this.tileMapSize.width; 0 <= ref ? k < ref : k > ref; x = 0 <= ref ? ++k : --k) {
        for (y = m = 0, ref1 = this.tileMapSize.height; 0 <= ref1 ? m < ref1 : m > ref1; y = 0 <= ref1 ? ++m : --m) {
          geographicTile = this.geographicTileMap[x][y];
          if (geographicTile.elevation <= 0) {
            geographicTile.tileGraphic = WaterTiles;
          } else if (geographicTile.elevation <= 4) {
            rainfall = geographicTile.rainfall;
            temperature = geographicTile.temperature;
            if (geographicTile.temperature > 90) {
              temperature = "Hot";
            } else if (geographicTile.temperature > 50) {
              temperature = "Temperate";
            } else if (geographicTile.temperature > 20) {
              temperature = "Cold";
            } else {
              temperature = "Freezing";
            }
            if (geographicTile.rainfall > 80) {
              rainfall = "Wet";
            } else if (geographicTile.rainfall > 30) {
              rainfall = "Moist";
            } else {
              rainfall = "Dry";
            }
            if (temperature === "Hot" && rainfall === "Wet") {
              geographicTile.tileGraphic = LeechedTiles;
            } else if (temperature === "Hot" && rainfall === "Moist") {
              geographicTile.tileGraphic = PrairieTiles;
            } else if (temperature === "Hot" && rainfall === "Dry") {
              geographicTile.tileGraphic = DesertTiles;
            } else if (temperature === "Temperate" && rainfall === "Wet") {
              geographicTile.tileGraphic = GrassTiles;
            } else if (temperature === "Temperate" && rainfall === "Moist") {
              geographicTile.tileGraphic = GrassTiles;
            } else if (temperature === "Temperate" && rainfall === "Dry") {
              geographicTile.tileGraphic = PlainTiles;
            } else if (temperature === "Cold") {
              if (rainfall === "Dry") {
                geographicTile.tileGraphic = DesertTiles;
              } else {
                geographicTile.tileGraphic = TaigaTiles;
              }
            } else if (temperature === "Freezing") {
              geographicTile.tileGraphic = PolarTiles;
            }
          } else {
            geographicTile.tileGraphic = null;
          }
        }
      }
      for (x = n = 0, ref2 = this.tileMapSize.width; 0 <= ref2 ? n < ref2 : n > ref2; x = 0 <= ref2 ? ++n : --n) {
        for (y = o = 0, ref3 = this.tileMapSize.height; 0 <= ref3 ? o < ref3 : o > ref3; y = 0 <= ref3 ? ++o : --o) {
          geographicTile = this.geographicTileMap[x][y];
          if (geographicTile.tileGraphic === null) {
            l = (x - 1 + this.tileMapSize.width) % this.tileMapSize.width;
            r = (x + 1) % this.tileMapSize.width;
            t = y - 1;
            b = y + 1;
            priority = tilePriority.indexOf(this.geographicTileMap[l][y].tileGraphic);
            if (this.geographicTileMap[x][t]) {
              newPriority = tilePriority.indexOf(this.geographicTileMap[x][t].tileGraphic);
              if (newPriority > priority) {
                priority = newPriority;
              }
            }
            if (this.geographicTileMap[x][b]) {
              newPriority = tilePriority.indexOf(this.geographicTileMap[x][b].tileGraphic);
              if (newPriority > priority) {
                priority = newPriority;
              }
            }
            newPriority = tilePriority.indexOf(this.geographicTileMap[r][y].tileGraphic);
            if (newPriority > priority) {
              priority = newPriority;
            }
            if (priority <= 0) {
              geographicTile.tileGraphic = DesertTiles;
            } else {
              geographicTile.tileGraphic = tilePriority[priority];
            }
          }
        }
      }
      tileSpriteFrameFunction = (function(_this) {
        return function(x, y, tileMap) {
          var geographicTileB, geographicTileT, ret, tileGraphic;
          geographicTile = _this.geographicTileMap[x][y];
          if (geographicTile.tiles) {
            return geographicTile.tiles;
          }
          tileGraphic = geographicTile.tileGraphic;
          geographicTile.tiles = ret = [randomArrayElement(tileGraphic.spriteFrames5)];
          if (false) {
            if (geographicTile.windDirection === 1) {
              ret.push(windSW);
            } else if (geographicTile.windDirection === 3) {
              ret.push(windSE);
            } else if (geographicTile.windDirection === 7) {
              ret.push(windNW);
            } else if (geographicTile.windDirection === 9) {
              ret.push(windNE);
            }
          }
          if (false) {
            if (geographicTile.rainfall > 75) {
              ret.push(rain100);
            } else if (geographicTile.rainfall > 50) {
              ret.push(rain75);
            } else if (geographicTile.rainfall > 25) {
              ret.push(rain50);
            } else {
              ret.push(rain25);
            }
          }
          l = (x - 1 + _this.tileMapSize.width) % _this.tileMapSize.width;
          r = (x + 1) % _this.tileMapSize.width;
          t = y - 1;
          b = y + 1;
          if (geographicTile.elevation === 0) {
            geographicTileT = _this.geographicTileMap[x][t];
            if (geographicTileT) {
              if (geographicTileT.elevation > 0) {
                ret = ret.concat(randomArrayElement(tileGraphic.spriteFrames7), randomArrayElement(tileGraphic.spriteFrames9), randomArrayElement(tileGraphic.spriteFrames8));
              } else {
                if (_this.geographicTileMap[l][t].elevation > 0) {
                  ret.push(randomArrayElement(tileGraphic.spriteFrames7));
                }
                if (_this.geographicTileMap[r][t].elevation > 0) {
                  ret.push(randomArrayElement(tileGraphic.spriteFrames9));
                }
              }
            }
            geographicTileB = _this.geographicTileMap[x][b];
            if (geographicTileB) {
              if (geographicTileB.elevation > 0) {
                ret = ret.concat(randomArrayElement(tileGraphic.spriteFrames1), randomArrayElement(tileGraphic.spriteFrames3), randomArrayElement(tileGraphic.spriteFrames2));
              } else {
                if (_this.geographicTileMap[l][b].elevation > 0) {
                  ret.push(randomArrayElement(tileGraphic.spriteFrames1));
                }
                if (_this.geographicTileMap[r][b].elevation > 0) {
                  ret.push(randomArrayElement(tileGraphic.spriteFrames3));
                }
              }
            }
            if (_this.geographicTileMap[l][y].elevation > 0) {
              ret = ret.concat(randomArrayElement(tileGraphic.spriteFrames7), randomArrayElement(tileGraphic.spriteFrames1), randomArrayElement(tileGraphic.spriteFrames4));
            }
            if (_this.geographicTileMap[r][y].elevation > 0) {
              ret = ret.concat(randomArrayElement(tileGraphic.spriteFrames9), randomArrayElement(tileGraphic.spriteFrames3), randomArrayElement(tileGraphic.spriteFrames6));
            }
          }
          return ret;
        };
      })(this);
      transitionSpriteFrameFunction = (function(_this) {
        return function(x, y, tileMap) {
          var adjacentTile1, adjacentTile2, adjacentTile3, adjacentTile4, adjacentTile6, adjacentTile7, adjacentTile8, adjacentTile9, adjacentTileGraphic1, adjacentTileGraphic2, adjacentTileGraphic3, adjacentTileGraphic4, adjacentTileGraphic6, adjacentTileGraphic7, adjacentTileGraphic8, adjacentTileGraphic9, blah, has1, has3, has7, has9, ret, tileGraphic;
          geographicTile = _this.geographicTileMap[x][y];
          if (geographicTile.transitions) {
            return geographicTile.transitions;
          }
          tileGraphic = geographicTile.tileGraphic;
          geographicTile.transitions = ret = [];
          l = (x - 1 + _this.tileMapSize.width) % _this.tileMapSize.width;
          r = (x + 1) % _this.tileMapSize.width;
          t = y - 1;
          b = y + 1;
          priority = tilePriority.indexOf(tileGraphic);
          adjacentTile8 = _this.geographicTileMap[x][t];
          adjacentTile7 = _this.geographicTileMap[l][t];
          adjacentTile4 = _this.geographicTileMap[l][y];
          adjacentTile1 = _this.geographicTileMap[l][b];
          adjacentTile2 = _this.geographicTileMap[x][b];
          adjacentTile3 = _this.geographicTileMap[r][b];
          adjacentTile6 = _this.geographicTileMap[r][y];
          adjacentTile9 = _this.geographicTileMap[r][t];
          has7 = false;
          has9 = false;
          if (adjacentTile8) {
            if (adjacentTile7.elevation > 0) {
              adjacentTileGraphic7 = adjacentTile7.tileGraphic;
            }
            if (adjacentTile9.elevation > 0) {
              adjacentTileGraphic9 = adjacentTile9.tileGraphic;
            }
            if (adjacentTile8.elevation > 0) {
              adjacentTileGraphic8 = adjacentTile8.tileGraphic;
            }
            if (adjacentTileGraphic7 && tilePriority.indexOf(adjacentTileGraphic7) > priority) {
              has7 = true;
              if (adjacentTileGraphic8 && tilePriority.indexOf(adjacentTileGraphic8) > tilePriority.indexOf(adjacentTileGraphic7)) {
                ret.push(randomArrayElement(adjacentTileGraphic8.spriteFrames7));
              } else {
                ret.push(randomArrayElement(adjacentTileGraphic7.spriteFrames7));
              }
            }
            if (adjacentTileGraphic9 && tilePriority.indexOf(adjacentTileGraphic9) > priority) {
              has9 = true;
              if (adjacentTileGraphic8 && tilePriority.indexOf(adjacentTileGraphic8) > tilePriority.indexOf(adjacentTileGraphic9)) {
                ret.push(randomArrayElement(adjacentTileGraphic8.spriteFrames9));
              } else {
                ret.push(randomArrayElement(adjacentTileGraphic9.spriteFrames9));
              }
            }
            if (adjacentTileGraphic8 && tilePriority.indexOf(adjacentTileGraphic8) > priority) {
              if (!has7) {
                ret.push(randomArrayElement(adjacentTileGraphic8.spriteFrames7));
              }
              if (!has9) {
                ret.push(randomArrayElement(adjacentTileGraphic8.spriteFrames9));
              }
              ret.push(randomArrayElement(adjacentTileGraphic8.spriteFrames8));
            }
          }
          has1 = false;
          has3 = false;
          if (adjacentTile2) {
            if (adjacentTile1.elevation > 0) {
              adjacentTileGraphic1 = adjacentTile1.tileGraphic;
            }
            if (adjacentTile3.elevation > 0) {
              adjacentTileGraphic3 = adjacentTile3.tileGraphic;
            }
            if (adjacentTile2.elevation > 0) {
              adjacentTileGraphic2 = adjacentTile2.tileGraphic;
            }
            if (adjacentTileGraphic1 && tilePriority.indexOf(adjacentTileGraphic1) > priority) {
              has1 = true;
              if (adjacentTileGraphic2 && tilePriority.indexOf(adjacentTileGraphic2) > tilePriority.indexOf(adjacentTileGraphic1)) {
                ret.push(randomArrayElement(adjacentTileGraphic2.spriteFrames1));
              } else {
                ret.push(randomArrayElement(adjacentTileGraphic1.spriteFrames1));
              }
            }
            if (adjacentTileGraphic3 && tilePriority.indexOf(adjacentTileGraphic3) > priority) {
              has3 = true;
              if (adjacentTileGraphic2 && tilePriority.indexOf(adjacentTileGraphic2) > tilePriority.indexOf(adjacentTileGraphic3)) {
                ret.push(randomArrayElement(adjacentTileGraphic2.spriteFrames3));
              } else {
                ret.push(randomArrayElement(adjacentTileGraphic3.spriteFrames3));
              }
            }
            if (adjacentTileGraphic2 && tilePriority.indexOf(adjacentTileGraphic2) > priority) {
              if (!has1) {
                ret.push(randomArrayElement(adjacentTileGraphic2.spriteFrames1));
              }
              if (!has3) {
                ret.push(randomArrayElement(adjacentTileGraphic2.spriteFrames3));
              }
              ret.push(randomArrayElement(adjacentTileGraphic2.spriteFrames2));
            }
          }
          if (adjacentTile4) {
            if (adjacentTile4.elevation > 0) {
              adjacentTileGraphic4 = adjacentTile4.tileGraphic;
            }
            if (adjacentTileGraphic4 && (blah = tilePriority.indexOf(adjacentTileGraphic4) > priority)) {
              if (!has7) {
                ret.push(randomArrayElement(adjacentTileGraphic4.spriteFrames7));
              }
              if (!has1) {
                ret.push(randomArrayElement(adjacentTileGraphic4.spriteFrames1));
              }
              ret.push(randomArrayElement(adjacentTileGraphic4.spriteFrames4));
            }
          }
          if (adjacentTile6) {
            if (adjacentTile6.elevation > 0) {
              adjacentTileGraphic6 = adjacentTile6.tileGraphic;
            }
            if (adjacentTileGraphic6 && (blah = tilePriority.indexOf(adjacentTileGraphic6) > priority)) {
              if (!has9) {
                ret.push(randomArrayElement(adjacentTileGraphic6.spriteFrames9));
              }
              if (!has3) {
                ret.push(randomArrayElement(adjacentTileGraphic6.spriteFrames3));
              }
              ret.push(randomArrayElement(adjacentTileGraphic6.spriteFrames6));
            }
          }
          if (geographicTile.elevation > 2 && geographicTile.elevation <= 4) {
            ret.push(randomArrayElement(tileGraphic.hills));
          }
          return ret;
        };
      })(this);
      doodadsSpriteFrameFunction = (function(_this) {
        return function(x, y, tileMap) {
          var grassCount, i, mt, offset, p, q, ref4, ref5, ref6, ref7, ref8, ret, s, tree, treeCount, u, v;
          geographicTile = _this.geographicTileMap[x][y];
          if (geographicTile.doodads) {
            return geographicTile.doodads;
          }
          geographicTile.doodads = ret = [];
          if (geographicTile.temperature > 90) {
            temperature = "Hot";
            treeCount = 4;
            grassCount = 3;
          } else if (geographicTile.temperature > 50) {
            temperature = "Temperate";
            treeCount = 3;
            grassCount = 1;
          } else if (geographicTile.temperature > 20) {
            temperature = "Cold";
            treeCount = 4;
            grassCount = 1;
          } else {
            temperature = "Freezing";
            treeCount = 0;
            grassCount = 0;
          }
          if (geographicTile.rainfall > 80) {
            rainfall = "Wet";
            treeCount *= 1.5;
            grassCount *= 2;
          } else if (geographicTile.rainfall > 30) {
            rainfall = "Moist";
            grassCount *= 1.5;
            treeCount = 0;
          } else {
            rainfall = "Dry";
            treeCount = 0;
          }
          if (temperature === "Temperate") {
            tree = leafyTree;
          } else if (temperature === "Hot") {
            tree = junglyTree;
          } else {
            tree = pineyTree;
          }
          if (geographicTile.elevation > 0) {
            if (geographicTile.elevation <= 2) {
              if (rainfall === "Wet" || rainfall === "Moist") {
                for (i = p = 0, ref4 = grassCount; 0 <= ref4 ? p < ref4 : p > ref4; i = 0 <= ref4 ? ++p : --p) {
                  offset = randomOffset(grassTuft, _this.tileSize);
                  ret.push({
                    spriteFrame: grassTuft,
                    x: offset.x,
                    y: offset.y
                  });
                }
              }
              if (rainfall === "Wet" || rainfall === "Moist") {
                for (i = q = 0, ref5 = treeCount; 0 <= ref5 ? q < ref5 : q > ref5; i = 0 <= ref5 ? ++q : --q) {
                  offset = randomOffset(tree, _this.tileSize);
                  ret.push({
                    spriteFrame: tree,
                    x: offset.x,
                    y: offset.y
                  });
                }
              }
              if (rainfall === "Dry" && temperature === "Temperate") {
                for (i = s = 0, ref6 = grassCount; 0 <= ref6 ? s < ref6 : s > ref6; i = 0 <= ref6 ? ++s : --s) {
                  offset = randomOffset(dryGrassTuft, _this.tileSize);
                  ret.push({
                    spriteFrame: dryGrassTuft,
                    x: offset.x,
                    y: offset.y
                  });
                }
              }
            } else if (geographicTile.elevation <= 4) {
              if (rainfall === "Wet" || rainfall === "Moist") {
                for (i = u = 0, ref7 = grassCount; 0 <= ref7 ? u < ref7 : u > ref7; i = 0 <= ref7 ? ++u : --u) {
                  offset = randomOffset(grassTuft, _this.tileSize);
                  ret.push({
                    spriteFrame: grassTuft,
                    x: offset.x,
                    y: Math.floor(offset.y - _this.tileSize.height / 8)
                  });
                }
                for (i = v = 0, ref8 = treeCount; 0 <= ref8 ? v < ref8 : v > ref8; i = 0 <= ref8 ? ++v : --v) {
                  offset = randomOffset(tree, _this.tileSize);
                  ret.push({
                    spriteFrame: tree,
                    x: offset.x,
                    y: Math.floor(offset.y - _this.tileSize.height / 8)
                  });
                }
              }
            } else {
              offset = randomOffset(mountain, _this.tileSize);
              if (geographicTile.tileGraphic === PolarTiles) {
                mt = icyMountain;
              } else if (geographicTile.tileGraphic === TaigaTiles || geographicTile.tileGraphic === GrassTiles) {
                mt = coldMountain;
              } else {
                mt = mountain;
              }
              ret.push({
                spriteFrame: mt,
                x: offset.x,
                y: Math.floor(offset.y / 2 + _this.tileSize.height / 3)
              });
              offset = randomOffset(mountain, _this.tileSize);
              ret.push({
                spriteFrame: mt,
                x: offset.x,
                y: Math.floor(offset.y / 2 + _this.tileSize.height / 4 * 3)
              });
            }
          }
          if (ret[0] && !ret[0].spriteFrame) {
            throw new Error("WHAT");
          }
          return ret;
        };
      })(this);
      return Background.create({
        tileMap: this.geographicTileMap,
        tileMapSize: this.tileMapSize,
        tileSize: this.tileSize,
        parentSprite: layerSprite,
        spatialHash: spatialHash,
        tileSpriteFrameFunction: tileSpriteFrameFunction,
        transitionSpriteFrameFunction: transitionSpriteFrameFunction,
        doodadsSpriteFrameFunction: doodadsSpriteFrameFunction
      });
    };

    return World;

  })();

}).call(this);
