// Generated by CoffeeScript 1.3.1
(function() {
  var ClimateGenerator, GeographicTile, GeographyGenerator, GeologyGenerator, TileGraphic, loadTiles, randomTile, sharedSpriteFrameCache,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  sharedSpriteFrameCache = cc.SpriteFrameCache.getInstance();

  GeographyGenerator = (function() {

    GeographyGenerator.name = 'GeographyGenerator';

    function GeographyGenerator(options) {
      this.options = options;
    }

    GeographyGenerator.prototype.run = function(world) {};

    return GeographyGenerator;

  })();

  GeologyGenerator = (function(_super) {

    __extends(GeologyGenerator, _super);

    GeologyGenerator.name = 'GeologyGenerator';

    function GeologyGenerator(options) {
      this.options = options;
      $.extend(this, {
        landCount: 1,
        oceanPlateCount: 1,
        fractionSubduction: 0.3,
        fractionLand: 0.3,
        hasEqualLand: true
      }, options);
    }

    GeologyGenerator.prototype.run = function(world) {
      var candidateList, candidateLists, direction, geographicTile, geographicTileMap, i, id, j, landCount, oceanPlateCount, point, points, randomSlots, randoms, requiredLandCount, requiredSubductionCount, subductionCount, tileMapSize, totalTileCount, x, y, _i, _j, _ref, _results;
      tileMapSize = world.tileMapSize;
      geographicTileMap = world.geographicTileMap;
      candidateLists = [];
      randoms = [];
      for (i = _i = 0, _ref = this.landPlateCount; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        x = Math.floor(tileMapSize.width * Math.random());
        y = Math.floor(tileMapSize.height * Math.random());
        candidateList = candidateLists[i] = [new cc.Point(x, y)];
        randomSlots = Math.random() * 10;
        randomSlots *= randomSlots * randomSlots * randomSlots * randomSlots;
        for (j = _j = 0; 0 <= randomSlots ? _j < randomSlots : _j > randomSlots; j = 0 <= randomSlots ? ++_j : --_j) {
          randoms.push(i);
        }
      }
      landCount = 0;
      totalTileCount = tileMapSize.width * tileMapSize.height;
      requiredLandCount = totalTileCount * this.fractionLand;
      while (landCount <= requiredLandCount) {
        id = randoms[Math.floor(randoms.length * Math.random())];
        candidateList = candidateLists[id];
        if (candidateList.length > 0) {
          i = Math.floor(candidateList.length * Math.random());
          point = candidateList.splice(i, 1)[0];
          x = point.x;
          y = point.y;
          geographicTile = geographicTileMap[x][y];
          if (!geographicTile.landPlateIds[id]) {
            geographicTile.landPlateIds[id] = true;
            geographicTile.landPlateIds.length++;
            geographicTile.elevation += 1 + Math.sqrt(Math.random() * 1.2);
            points = [];
            if (geographicTile.landPlateIds.length <= 1) {
              landCount++;
              points = [[x - 1, y], [x, y - 1], [x + 1, y], [x, y + 1]];
            } else {
              geographicTile.elevation += Math.sqrt(Math.random() * 2);
              direction = Math.floor(4 * Math.random());
              if (direction === 0) {
                points.push([x - 1, y]);
              } else if (direction === 1) {
                points.push([x, y - 1]);
              } else if (direction === 2) {
                points.push([x + 1, y]);
              } else if (direction === 3) {
                points.push([x, y + 1]);
              }
            }
            this.addToCandidates(candidateList, geographicTileMap, tileMapSize, points);
          }
        }
      }
      oceanPlateCount = this.oceanPlateCount;
      requiredSubductionCount = this.fractionSubduction * totalTileCount;
      candidateList = [];
      while (oceanPlateCount > 0) {
        x = Math.floor(tileMapSize.width * Math.random());
        y = Math.floor(tileMapSize.height * Math.random());
        geographicTile = geographicTileMap[x][y];
        if (geographicTileMap[x][y].elevation === 0) {
          candidateList.push(new cc.Point(x, y));
          oceanPlateCount--;
        }
      }
      subductionCount = 0;
      _results = [];
      while (subductionCount <= requiredSubductionCount && candidateList.length > 0) {
        i = Math.floor(candidateList.length * Math.random());
        point = candidateList.splice(i, 1)[0];
        x = point.x;
        y = point.y;
        geographicTile = geographicTileMap[x][y];
        if (geographicTile.subduction === false) {
          if (geographicTile.landPlateIds.length === 0) {
            geographicTile.subduction = true;
            subductionCount += 1;
            _results.push(this.addToCandidates(candidateList, geographicTileMap, tileMapSize, [[x - 1, y], [x, y - 1], [x + 1, y], [x, y + 1], [x - 2, y], [x - 1, y - 1], [x, y - 2], [x + 1, y - 1], [x + 2, y], [x + 1, y + 1], [x, y + 2]], 2));
          } else {
            _results.push(geographicTile.elevation += Math.sqrt(Math.random() * 2));
          }
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    GeologyGenerator.prototype.addToCandidates = function(candidateList, geographicTileMap, tileMapSize, points, heightTolerance) {
      var point, x, y, _i, _len, _results;
      if (!(heightTolerance != null)) {
        heightTolerance = 1000;
      }
      _results = [];
      for (_i = 0, _len = points.length; _i < _len; _i++) {
        point = points[_i];
        x = point[0];
        y = point[1];
        x = (x + tileMapSize.width) % tileMapSize.width;
        if (y >= 0 && y < tileMapSize.height && geographicTileMap[x] && geographicTileMap[x][y].elevation <= heightTolerance) {
          _results.push(candidateList.push(new cc.Point(x, (y + tileMapSize.height) % tileMapSize.height)));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    return GeologyGenerator;

  })(GeographyGenerator);

  ClimateGenerator = (function(_super) {

    __extends(ClimateGenerator, _super);

    ClimateGenerator.name = 'ClimateGenerator';

    function ClimateGenerator(options) {
      this.options = options;
      $.extend(this, {
        minTemperature: -50,
        maxTemperature: 100,
        minRainfall: 0,
        maxRainfall: 100,
        rainfallReductionRate: 4
      }, options);
      this.temperatureRange = this.maxTemperature - this.minTemperature;
      this.rainfallRange = this.maxRainfall - this.minRainfall;
      this.rainfallReductionRateDiagonal = this.rainfallReductionRate * Math.SQRT2;
      this.mountainRainfallReductionRate = this.rainfallReductionRate * 10;
      this.mountainRainfallReductionRateDiagonal = this.rainfallReductionRateDiagonal * 10;
      this.surroundingRainfallReductionRate = this.rainfallReductionRate * 5;
    }

    ClimateGenerator.prototype.run = function(world) {
      var geographicTileMap, halfHeight1, halfHeight2, halfPi, halfPiRatio, temperature, tileMapSize, x, y, _i, _j, _ref, _ref1,
        _this = this;
      tileMapSize = world.tileMapSize;
      geographicTileMap = world.geographicTileMap;
      halfPi = Math.PI / 2;
      halfHeight1 = tileMapSize.height / 2;
      halfHeight2 = Math.floor(halfHeight1);
      if (halfHeight1 === halfHeight2) {
        halfHeight1 -= 1;
      } else {
        halfHeight1 = halfHeight2;
      }
      halfPiRatio = halfPi / halfHeight2;
      for (x = _i = 0, _ref = tileMapSize.width; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        for (y = _j = 0, _ref1 = halfHeight1 + 1; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
          temperature = this.temperatureRange * Math.cos(halfPiRatio * y) + this.minTemperature;
          geographicTileMap[x][halfHeight1 - y].temperature = temperature;
          geographicTileMap[x][halfHeight2 + y].temperature = temperature;
        }
      }
      return Async.series(function() {
        return _this.hadleyCells(tileMapSize, geographicTileMap, halfHeight1, halfHeight2);
      }, function() {
        return _this.rainfall(tileMapSize, geographicTileMap);
      }, function() {
        return _this.temperatureModeration(tileMapSize, geographicTileMap);
      });
    };

    ClimateGenerator.prototype.hadleyCells = function(tileMapSize, geographicTileMap, halfHeight1, halfHeight2) {
      var degree30, degree60, x, y, _i, _j, _k, _ref, _results;
      degree30 = Math.floor(Math.sin(Math.PI / 6) * halfHeight2);
      degree60 = Math.floor(Math.sin(Math.PI / 3) * halfHeight2);
      _results = [];
      for (x = _i = 0, _ref = tileMapSize.width; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        for (y = _j = 0; 0 <= degree30 ? _j < degree30 : _j > degree30; y = 0 <= degree30 ? ++_j : --_j) {
          geographicTileMap[x][halfHeight1 - y].windDirection = 9;
          geographicTileMap[x][halfHeight2 + y].windDirection = 3;
        }
        for (y = _k = degree30; degree30 <= degree60 ? _k < degree60 : _k > degree60; y = degree30 <= degree60 ? ++_k : --_k) {
          geographicTileMap[x][halfHeight1 - y].windDirection = 1;
          geographicTileMap[x][halfHeight2 + y].windDirection = 7;
        }
        _results.push((function() {
          var _l, _ref1, _results1;
          _results1 = [];
          for (y = _l = degree60, _ref1 = halfHeight1 + 1; degree60 <= _ref1 ? _l < _ref1 : _l > _ref1; y = degree60 <= _ref1 ? ++_l : --_l) {
            geographicTileMap[x][halfHeight1 - y].windDirection = 9;
            _results1.push(geographicTileMap[x][halfHeight2 + y].windDirection = 3);
          }
          return _results1;
        })());
      }
      return _results;
    };

    ClimateGenerator.prototype.rainfall = function(tileMapSize, geographicTileMap) {
      var candidate, candidateList, geographicTile, i, percentDeviation, rainfall, x, y, _i, _j, _k, _l, _len, _m, _n, _o, _p, _q, _r, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9, _results, _s, _t;
      candidateList = [];
      for (x = _i = 0, _ref = tileMapSize.width; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        for (y = _j = 0, _ref1 = tileMapSize.height; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
          if (geographicTileMap[x][y].elevation === 0) {
            candidateList.push(new cc.Point(x, y));
          }
        }
      }
      for (_k = 0, _len = candidateList.length; _k < _len; _k++) {
        candidate = candidateList[_k];
        x = candidate.x;
        y = candidate.y;
        rainfall = this.maxRainfall;
        geographicTile = geographicTileMap[x][y];
        i = 1;
        while (rainfall > 0) {
          if (!(geographicTile != null)) {
            break;
          }
          if (geographicTile.elevation > 4) {
            rainfall -= this.mountainRainfallReductionRateDiagonal;
          }
          geographicTile.rainfall = Math.max(rainfall, geographicTile.rainfall);
          if (geographicTile.windDirection === 9) {
            x = (x - 1 + tileMapSize.width) % tileMapSize.width;
            y++;
          } else if (geographicTile.windDirection === 3) {
            x = (x - 1 + tileMapSize.width) % tileMapSize.width;
            y--;
          } else if (geographicTile.windDirection === 1) {
            x = (x + 1) % tileMapSize.width;
            y--;
          } else if (geographicTile.windDirection === 7) {
            x = (x + 1) % tileMapSize.width;
            y++;
          } else {
            throw new Error("this shouldn't happen");
          }
          rainfall -= this.rainfallReductionRateDiagonal;
          geographicTile = geographicTileMap[x][y];
          i++;
        }
        if (geographicTile != null) {
          geographicTile.rainfall = Math.max(rainfall, geographicTile.rainfall);
        }
      }
      _results = [];
      for (i = _l = 0; _l < 2; i = ++_l) {
        for (x = _m = 0, _ref2 = tileMapSize.width; 0 <= _ref2 ? _m < _ref2 : _m > _ref2; x = 0 <= _ref2 ? ++_m : --_m) {
          for (y = _n = 0, _ref3 = tileMapSize.height; 0 <= _ref3 ? _n < _ref3 : _n > _ref3; y = 0 <= _ref3 ? ++_n : --_n) {
            this.diffuseRainfall(tileMapSize, geographicTileMap, x, y);
          }
        }
        for (x = _o = _ref4 = tileMapSize.width - 1; _ref4 <= -1 ? _o < -1 : _o > -1; x = _ref4 <= -1 ? ++_o : --_o) {
          for (y = _p = 0, _ref5 = tileMapSize.height; 0 <= _ref5 ? _p < _ref5 : _p > _ref5; y = 0 <= _ref5 ? ++_p : --_p) {
            this.diffuseRainfall(tileMapSize, geographicTileMap, x, y);
          }
        }
        for (x = _q = _ref6 = tileMapSize.width - 1; _ref6 <= -1 ? _q < -1 : _q > -1; x = _ref6 <= -1 ? ++_q : --_q) {
          for (y = _r = _ref7 = tileMapSize.height - 1; _ref7 <= -1 ? _r < -1 : _r > -1; y = _ref7 <= -1 ? ++_r : --_r) {
            this.diffuseRainfall(tileMapSize, geographicTileMap, x, y);
          }
        }
        for (x = _s = 0, _ref8 = tileMapSize.width; 0 <= _ref8 ? _s < _ref8 : _s > _ref8; x = 0 <= _ref8 ? ++_s : --_s) {
          for (y = _t = 0, _ref9 = tileMapSize.height; 0 <= _ref9 ? _t < _ref9 : _t > _ref9; y = 0 <= _ref9 ? ++_t : --_t) {
            this.diffuseRainfall(tileMapSize, geographicTileMap, x, y);
          }
        }
        _results.push((function() {
          var _ref10, _results1, _u;
          _results1 = [];
          for (x = _u = 0, _ref10 = tileMapSize.width; 0 <= _ref10 ? _u < _ref10 : _u > _ref10; x = 0 <= _ref10 ? ++_u : --_u) {
            _results1.push((function() {
              var _ref11, _results2, _v;
              _results2 = [];
              for (y = _v = 0, _ref11 = tileMapSize.height; 0 <= _ref11 ? _v < _ref11 : _v > _ref11; y = 0 <= _ref11 ? ++_v : --_v) {
                geographicTile = geographicTileMap[x][y];
                percentDeviation = Math.random() * .2 + .9;
                geographicTile.rainfall *= percentDeviation;
                percentDeviation = Math.random() * .2 + .9;
                _results2.push(geographicTile.temperature *= percentDeviation);
              }
              return _results2;
            })());
          }
          return _results1;
        })());
      }
      return _results;
    };

    ClimateGenerator.prototype.temperatureModeration = function(tileMapSize, geographicTileMap) {
      var x, y, _i, _ref, _results;
      _results = [];
      for (x = _i = 0, _ref = tileMapSize.width; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref1, _results1;
          _results1 = [];
          for (y = _j = 0, _ref1 = tileMapSize.height; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
            _results1.push(geographicTileMap[x][y].temperature += (geographicTileMap[x][y].rainfall * this.temperatureRange) / 1000 + this.minTemperature / 10);
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    ClimateGenerator.prototype.diffuseRainfall = function(tileMapSize, geographicTileMap, x, y) {
      var geographicTile, referenceRainfall1, referenceRainfall2, referenceRainfall3, referenceRainfall4;
      geographicTile = geographicTileMap[x][y];
      referenceRainfall2 = 0;
      referenceRainfall3 = 0;
      referenceRainfall4 = 0;
      if (geographicTile.elevation <= 4) {
        if (geographicTile.windDirection === 1) {
          referenceRainfall1 = geographicTileMap[(x - 1 + tileMapSize.width) % tileMapSize.width][y].rainfall - this.rainfallReductionRate;
          if (y + 1 < tileMapSize.height) {
            referenceRainfall2 = geographicTileMap[(x - 1 + tileMapSize.width) % tileMapSize.width][y + 1].rainfall - this.rainfallReductionRateDiagonal;
          }
          if (y - 1 > 0) {
            referenceRainfall3 = geographicTileMap[x][y - 1].rainfall - this.surroundingRainfallReductionRate;
          }
          if (y + 1 < tileMapSize.height) {
            referenceRainfall4 = geographicTileMap[x][y + 1].rainfall - this.surroundingRainfallReductionRate;
          }
        } else if (geographicTile.windDirection === 7) {
          referenceRainfall1 = geographicTileMap[(x - 1 + tileMapSize.width) % tileMapSize.width][y].rainfall - this.rainfallReductionRate;
          if (y - 1 > 0) {
            referenceRainfall2 = geographicTileMap[(x - 1 + tileMapSize.width) % tileMapSize.width][y - 1].rainfall - this.rainfallReductionRateDiagonal;
          }
          if (y - 1 > 0) {
            referenceRainfall3 = geographicTileMap[x][y - 1].rainfall - this.surroundingRainfallReductionRate;
          }
          if (y + 1 < tileMapSize.height) {
            referenceRainfall4 = geographicTileMap[x][y + 1].rainfall - this.surroundingRainfallReductionRate;
          }
        } else if (geographicTile.windDirection === 3) {
          referenceRainfall1 = geographicTileMap[(x + 1) % tileMapSize.width][y].rainfall - this.rainfallReductionRate;
          if (y + 1 < tileMapSize.height) {
            referenceRainfall2 = geographicTileMap[(x + 1) % tileMapSize.width][y + 1].rainfall - this.rainfallReductionRateDiagonal;
          }
          if (y - 1 > 0) {
            referenceRainfall3 = geographicTileMap[x][y - 1].rainfall - this.surroundingRainfallReductionRate;
          }
          if (y + 1 < tileMapSize.height) {
            referenceRainfall4 = geographicTileMap[x][y + 1].rainfall - this.surroundingRainfallReductionRate;
          }
        } else if (geographicTile.windDirection === 9) {
          referenceRainfall1 = geographicTileMap[(x + 1) % tileMapSize.width][y].rainfall - this.rainfallReductionRate;
          if (y - 1 > 0) {
            referenceRainfall2 = geographicTileMap[(x + 1) % tileMapSize.width][y - 1].rainfall - this.rainfallReductionRateDiagonal;
          }
          if (y - 1 > 0) {
            referenceRainfall3 = geographicTileMap[x][y - 1].rainfall - this.surroundingRainfallReductionRate;
          }
          if (y + 1 < tileMapSize.height) {
            referenceRainfall4 = geographicTileMap[x][y + 1].rainfall - this.surroundingRainfallReductionRate;
          }
        }
        geographicTile.rainfall = Math.max(referenceRainfall1, referenceRainfall2, referenceRainfall3, referenceRainfall4, geographicTile.rainfall);
        if (isNaN(geographicTile.rainfall)) {
          throw new Error("NAN");
        }
      }
    };

    return ClimateGenerator;

  })(GeographyGenerator);

  GeographicTile = (function() {

    GeographicTile.name = 'GeographicTile';

    function GeographicTile(options) {
      this.options = options;
      $.extend(this, {
        elevation: 0,
        temperature: 0,
        windDirection: 5,
        rainfall: -1,
        landPlateIds: {
          length: 0
        },
        subduction: false,
        tileGraphic: null
      }, options);
    }

    return GeographicTile;

  })();

  TileGraphic = (function() {

    TileGraphic.name = 'TileGraphic';

    function TileGraphic(options) {
      this.options = options;
      $.extend(this, {
        spriteFrames5: [],
        spriteFrames8: [],
        spriteFrames7: [],
        spriteFrames4: [],
        spriteFrames1: [],
        spriteFrames2: [],
        spriteFrames3: [],
        spriteFrames6: [],
        spriteFrames9: []
      }, this.options);
    }

    return TileGraphic;

  })();

  loadTiles = function(name) {
    return {
      spriteFrames5: [sharedSpriteFrameCache.getSpriteFrame(name + "1"), sharedSpriteFrameCache.getSpriteFrame(name + "2"), sharedSpriteFrameCache.getSpriteFrame(name + "3"), sharedSpriteFrameCache.getSpriteFrame(name + "4")],
      spriteFrames8: [sharedSpriteFrameCache.getSpriteFrame(name + "T1"), sharedSpriteFrameCache.getSpriteFrame(name + "T2")],
      spriteFrames7: [sharedSpriteFrameCache.getSpriteFrame(name + "TL1")],
      spriteFrames4: [sharedSpriteFrameCache.getSpriteFrame(name + "L1"), sharedSpriteFrameCache.getSpriteFrame(name + "L2")],
      spriteFrames1: [sharedSpriteFrameCache.getSpriteFrame(name + "BL1")],
      spriteFrames2: [sharedSpriteFrameCache.getSpriteFrame(name + "B1"), sharedSpriteFrameCache.getSpriteFrame(name + "B2")],
      spriteFrames3: [sharedSpriteFrameCache.getSpriteFrame(name + "BR1")],
      spriteFrames6: [sharedSpriteFrameCache.getSpriteFrame(name + "R1"), sharedSpriteFrameCache.getSpriteFrame(name + "R2")],
      spriteFrames9: [sharedSpriteFrameCache.getSpriteFrame(name + "TR1")]
    };
  };

  randomTile = function(tiles) {
    return tiles[Math.floor(tiles.length * Math.random())];
  };

  this.World = (function() {

    World.name = 'World';

    function World(options) {
      var generatorOptions, i, j, _i, _j, _ref, _ref1,
        _this = this;
      this.options = options;
      this.tileSize = options.tileSize;
      this.worldSize = options.worldSize;
      this.tileMapSize = new cc.Size(this.worldSize.width / this.tileSize.width, this.worldSize.height / this.tileSize.height);
      this.geographicTileMap = [];
      for (i = _i = 0, _ref = this.tileMapSize.width; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.geographicTileMap[i] = [];
        for (j = _j = 0, _ref1 = this.tileMapSize.height; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          this.geographicTileMap[i][j] = new GeographicTile();
        }
      }
      generatorOptions = {
        tileMapSize: this.tileMapSize
      };
      $.extend(generatorOptions, options);
      this.geologyGenerator = new GeologyGenerator(generatorOptions);
      this.climateGenerator = new ClimateGenerator(generatorOptions);
      Async.series(function() {
        return _this.geologyGenerator.run(_this);
      }, function() {
        return _this.climateGenerator.run(_this);
      });
    }

    World.prototype.createSprites = function(layerSprite, spatialHash) {
      var DesertTiles, GrassTiles, LeechedTiles, PlainTiles, PolarTiles, PrairieTiles, TaigaTiles, WaterTiles, addTransitions, b, doodadsSpriteFrameFunction, geographicTile, grassTuft, hill, junglyTree, l, leafyTree, mountain, newPriority, pineyTree, priority, r, rain100, rain25, rain50, rain75, rainfall, t, temperature, tilePriority, tileSpriteFrameFunction, transitionSpriteFrameFunction, windNE, windNW, windSE, windSW, x, y, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3,
        _this = this;
      WaterTiles = new TileGraphic({
        spriteFrames5: [sharedSpriteFrameCache.getSpriteFrame("Water1")],
        spriteFrames8: [sharedSpriteFrameCache.getSpriteFrame("BeachT1")],
        spriteFrames7: [sharedSpriteFrameCache.getSpriteFrame("BeachTL1")],
        spriteFrames4: [sharedSpriteFrameCache.getSpriteFrame("BeachL1")],
        spriteFrames1: [sharedSpriteFrameCache.getSpriteFrame("BeachBL1")],
        spriteFrames2: [sharedSpriteFrameCache.getSpriteFrame("BeachB1")],
        spriteFrames3: [sharedSpriteFrameCache.getSpriteFrame("BeachBR1")],
        spriteFrames6: [sharedSpriteFrameCache.getSpriteFrame("BeachR1")],
        spriteFrames9: [sharedSpriteFrameCache.getSpriteFrame("BeachTR1")]
      });
      GrassTiles = new TileGraphic(loadTiles("Grassland"));
      LeechedTiles = new TileGraphic(loadTiles("Leeched"));
      PrairieTiles = new TileGraphic(loadTiles("Prairie"));
      DesertTiles = new TileGraphic(loadTiles("Desert"));
      PlainTiles = new TileGraphic(loadTiles("Plain"));
      TaigaTiles = new TileGraphic(loadTiles("Taiga"));
      PolarTiles = new TileGraphic(loadTiles("Polar"));
      tilePriority = [PrairieTiles, GrassTiles, PlainTiles, TaigaTiles, LeechedTiles, PolarTiles, DesertTiles, WaterTiles].reverse();
      grassTuft = sharedSpriteFrameCache.getSpriteFrame("GrassTuft1");
      leafyTree = sharedSpriteFrameCache.getSpriteFrame("Tree1");
      pineyTree = sharedSpriteFrameCache.getSpriteFrame("Tree2");
      junglyTree = sharedSpriteFrameCache.getSpriteFrame("Tree3");
      mountain = sharedSpriteFrameCache.getSpriteFrame("Mountain1");
      hill = sharedSpriteFrameCache.getSpriteFrame("Hill1");
      windSW = sharedSpriteFrameCache.getSpriteFrame("SW");
      windSE = sharedSpriteFrameCache.getSpriteFrame("SE");
      windNW = sharedSpriteFrameCache.getSpriteFrame("NW");
      windNE = sharedSpriteFrameCache.getSpriteFrame("NE");
      rain100 = sharedSpriteFrameCache.getSpriteFrame("100");
      rain75 = sharedSpriteFrameCache.getSpriteFrame("75");
      rain50 = sharedSpriteFrameCache.getSpriteFrame("50");
      rain25 = sharedSpriteFrameCache.getSpriteFrame("25");
      for (x = _i = 0, _ref = this.tileMapSize.width; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        for (y = _j = 0, _ref1 = this.tileMapSize.height; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
          geographicTile = this.geographicTileMap[x][y];
          if (geographicTile.elevation <= 0) {
            geographicTile.tileGraphic = WaterTiles;
          } else if (geographicTile.elevation <= 4) {
            rainfall = geographicTile.rainfall;
            temperature = geographicTile.temperature;
            if (geographicTile.temperature > 90) {
              temperature = "Hot";
            } else if (geographicTile.temperature > 50) {
              temperature = "Temperate";
            } else if (geographicTile.temperature > 20) {
              temperature = "Cold";
            } else {
              temperature = "Freezing";
            }
            if (geographicTile.rainfall > 70) {
              rainfall = "Wet";
            } else if (geographicTile.rainfall > 30) {
              rainfall = "Moist";
            } else {
              rainfall = "Dry";
            }
            if (temperature === "Hot" && rainfall === "Wet") {
              geographicTile.tileGraphic = LeechedTiles;
            } else if (temperature === "Hot" && rainfall === "Moist") {
              geographicTile.tileGraphic = PrairieTiles;
            } else if (temperature === "Hot" && rainfall === "Dry") {
              geographicTile.tileGraphic = DesertTiles;
            } else if (temperature === "Temperate" && rainfall === "Wet") {
              geographicTile.tileGraphic = GrassTiles;
            } else if (temperature === "Temperate" && rainfall === "Moist") {
              geographicTile.tileGraphic = GrassTiles;
            } else if (temperature === "Temperate" && rainfall === "Dry") {
              geographicTile.tileGraphic = PlainTiles;
            } else if (temperature === "Cold") {
              if (rainfall === "Dry") {
                geographicTile.tileGraphic = DesertTiles;
              } else {
                geographicTile.tileGraphic = TaigaTiles;
              }
            } else if (temperature === "Freezing") {
              geographicTile.tileGraphic = PolarTiles;
            }
          } else {
            geographicTile.tileGraphic = null;
          }
        }
      }
      for (x = _k = 0, _ref2 = this.tileMapSize.width; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; x = 0 <= _ref2 ? ++_k : --_k) {
        for (y = _l = 0, _ref3 = this.tileMapSize.height; 0 <= _ref3 ? _l < _ref3 : _l > _ref3; y = 0 <= _ref3 ? ++_l : --_l) {
          geographicTile = this.geographicTileMap[x][y];
          if (geographicTile.tileGraphic === null) {
            l = (x - 1 + this.tileMapSize.width) % this.tileMapSize.width;
            r = (x + 1) % this.tileMapSize.width;
            t = y - 1;
            b = y + 1;
            priority = tilePriority.indexOf(this.geographicTileMap[l][y].tileGraphic);
            if (this.geographicTileMap[x][t]) {
              newPriority = tilePriority.indexOf(this.geographicTileMap[x][t].tileGraphic);
              if (newPriority > priority) {
                priority = newPriority;
              }
            }
            if (this.geographicTileMap[x][b]) {
              newPriority = tilePriority.indexOf(this.geographicTileMap[x][b].tileGraphic);
              if (newPriority > priority) {
                priority = newPriority;
              }
            }
            newPriority = tilePriority.indexOf(this.geographicTileMap[r][y].tileGraphic);
            if (newPriority > priority) {
              priority = newPriority;
            }
            if (priority <= 0) {
              geographicTile.tileGraphic = DesertTiles;
            } else {
              geographicTile.tileGraphic = tilePriority[priority];
            }
          }
        }
      }
      addTransitions = function(x, y, tileMap) {};
      tileSpriteFrameFunction = function(x, y, tileMap) {
        var geographicTileB, geographicTileT, ret, tileGraphic;
        geographicTile = _this.geographicTileMap[x][y];
        tileGraphic = geographicTile.tileGraphic;
        ret = [randomTile(tileGraphic.spriteFrames5)];
        if (false) {
          if (geographicTile.windDirection === 1) {
            ret.push(windSW);
          } else if (geographicTile.windDirection === 3) {
            ret.push(windSE);
          } else if (geographicTile.windDirection === 7) {
            ret.push(windNW);
          } else if (geographicTile.windDirection === 9) {
            ret.push(windNE);
          }
        }
        if (false) {
          if (geographicTile.rainfall > 75) {
            ret.push(rain100);
          } else if (geographicTile.rainfall > 50) {
            ret.push(rain75);
          } else if (geographicTile.rainfall > 25) {
            ret.push(rain50);
          } else {
            ret.push(rain25);
          }
        }
        l = (x - 1 + _this.tileMapSize.width) % _this.tileMapSize.width;
        r = (x + 1) % _this.tileMapSize.width;
        t = y - 1;
        b = y + 1;
        if (geographicTile.elevation === 0) {
          geographicTileT = _this.geographicTileMap[x][t];
          if (geographicTileT) {
            if (geographicTileT.elevation > 0) {
              ret = ret.concat(randomTile(tileGraphic.spriteFrames7), randomTile(tileGraphic.spriteFrames9), randomTile(tileGraphic.spriteFrames8));
            } else {
              if (_this.geographicTileMap[l][t].elevation > 0) {
                ret.push(randomTile(tileGraphic.spriteFrames7));
              }
              if (_this.geographicTileMap[r][t].elevation > 0) {
                ret.push(randomTile(tileGraphic.spriteFrames9));
              }
            }
          }
          geographicTileB = _this.geographicTileMap[x][b];
          if (geographicTileB) {
            if (geographicTileB.elevation > 0) {
              ret = ret.concat(randomTile(tileGraphic.spriteFrames1), randomTile(tileGraphic.spriteFrames3), randomTile(tileGraphic.spriteFrames2));
            } else {
              if (_this.geographicTileMap[l][b].elevation > 0) {
                ret.push(randomTile(tileGraphic.spriteFrames1));
              }
              if (_this.geographicTileMap[r][b].elevation > 0) {
                ret.push(randomTile(tileGraphic.spriteFrames3));
              }
            }
          }
          if (_this.geographicTileMap[l][y].elevation > 0) {
            ret = ret.concat(randomTile(tileGraphic.spriteFrames7), randomTile(tileGraphic.spriteFrames1), randomTile(tileGraphic.spriteFrames4));
          }
          if (_this.geographicTileMap[r][y].elevation > 0) {
            ret = ret.concat(randomTile(tileGraphic.spriteFrames9), randomTile(tileGraphic.spriteFrames3), randomTile(tileGraphic.spriteFrames6));
          }
        }
        return ret;
      };
      transitionSpriteFrameFunction = function(x, y, tileMap) {
        var adjacentTile1, adjacentTile2, adjacentTile3, adjacentTile4, adjacentTile6, adjacentTile7, adjacentTile8, adjacentTile9, adjacentTileGraphic1, adjacentTileGraphic2, adjacentTileGraphic3, adjacentTileGraphic4, adjacentTileGraphic6, adjacentTileGraphic7, adjacentTileGraphic8, adjacentTileGraphic9, blah, has1, has3, has7, has9, ret, tileGraphic;
        geographicTile = _this.geographicTileMap[x][y];
        tileGraphic = geographicTile.tileGraphic;
        ret = [];
        l = (x - 1 + _this.tileMapSize.width) % _this.tileMapSize.width;
        r = (x + 1) % _this.tileMapSize.width;
        t = y - 1;
        b = y + 1;
        priority = tilePriority.indexOf(tileGraphic);
        adjacentTile8 = _this.geographicTileMap[x][t];
        adjacentTile7 = _this.geographicTileMap[l][t];
        adjacentTile4 = _this.geographicTileMap[l][y];
        adjacentTile1 = _this.geographicTileMap[l][b];
        adjacentTile2 = _this.geographicTileMap[x][b];
        adjacentTile3 = _this.geographicTileMap[r][b];
        adjacentTile6 = _this.geographicTileMap[r][y];
        adjacentTile9 = _this.geographicTileMap[r][t];
        has7 = false;
        has9 = false;
        if (adjacentTile8) {
          if (adjacentTile7.elevation > 0) {
            adjacentTileGraphic7 = adjacentTile7.tileGraphic;
          }
          if (adjacentTile9.elevation > 0) {
            adjacentTileGraphic9 = adjacentTile9.tileGraphic;
          }
          if (adjacentTile8.elevation > 0) {
            adjacentTileGraphic8 = adjacentTile8.tileGraphic;
          }
          if (adjacentTileGraphic7 && tilePriority.indexOf(adjacentTileGraphic7) > priority) {
            has7 = true;
            if (adjacentTileGraphic8 && tilePriority.indexOf(adjacentTileGraphic8) > tilePriority.indexOf(adjacentTileGraphic7)) {
              ret.push(randomTile(adjacentTileGraphic8.spriteFrames7));
            } else {
              ret.push(randomTile(adjacentTileGraphic7.spriteFrames7));
            }
          }
          if (adjacentTileGraphic9 && tilePriority.indexOf(adjacentTileGraphic9) > priority) {
            has9 = true;
            if (adjacentTileGraphic8 && tilePriority.indexOf(adjacentTileGraphic8) > tilePriority.indexOf(adjacentTileGraphic9)) {
              ret.push(randomTile(adjacentTileGraphic8.spriteFrames9));
            } else {
              ret.push(randomTile(adjacentTileGraphic9.spriteFrames9));
            }
          }
          if (adjacentTileGraphic8 && tilePriority.indexOf(adjacentTileGraphic8) > priority) {
            if (!has7) {
              ret.push(randomTile(adjacentTileGraphic8.spriteFrames7));
            }
            if (!has9) {
              ret.push(randomTile(adjacentTileGraphic8.spriteFrames9));
            }
            ret.push(randomTile(adjacentTileGraphic8.spriteFrames8));
          }
        }
        has1 = false;
        has3 = false;
        if (adjacentTile2) {
          if (adjacentTile1.elevation > 0) {
            adjacentTileGraphic1 = adjacentTile1.tileGraphic;
          }
          if (adjacentTile3.elevation > 0) {
            adjacentTileGraphic3 = adjacentTile3.tileGraphic;
          }
          if (adjacentTile2.elevation > 0) {
            adjacentTileGraphic2 = adjacentTile2.tileGraphic;
          }
          if (adjacentTileGraphic1 && tilePriority.indexOf(adjacentTileGraphic1) > priority) {
            has1 = true;
            if (adjacentTileGraphic2 && tilePriority.indexOf(adjacentTileGraphic2) > tilePriority.indexOf(adjacentTileGraphic1)) {
              ret.push(randomTile(adjacentTileGraphic2.spriteFrames1));
            } else {
              ret.push(randomTile(adjacentTileGraphic1.spriteFrames1));
            }
          }
          if (adjacentTileGraphic3 && tilePriority.indexOf(adjacentTileGraphic3) > priority) {
            has3 = true;
            if (adjacentTileGraphic2 && tilePriority.indexOf(adjacentTileGraphic2) > tilePriority.indexOf(adjacentTileGraphic3)) {
              ret.push(randomTile(adjacentTileGraphic2.spriteFrames3));
            } else {
              ret.push(randomTile(adjacentTileGraphic3.spriteFrames3));
            }
          }
          if (adjacentTileGraphic2 && tilePriority.indexOf(adjacentTileGraphic2) > priority) {
            if (!has1) {
              ret.push(randomTile(adjacentTileGraphic2.spriteFrames1));
            }
            if (!has3) {
              ret.push(randomTile(adjacentTileGraphic2.spriteFrames3));
            }
            ret.push(randomTile(adjacentTileGraphic2.spriteFrames2));
          }
        }
        if (adjacentTile4) {
          if (adjacentTile4.elevation > 0) {
            adjacentTileGraphic4 = adjacentTile4.tileGraphic;
          }
          if (adjacentTileGraphic4 && (blah = tilePriority.indexOf(adjacentTileGraphic4) > priority)) {
            if (!has7) {
              ret.push(randomTile(adjacentTileGraphic4.spriteFrames7));
            }
            if (!has1) {
              ret.push(randomTile(adjacentTileGraphic4.spriteFrames1));
            }
            ret.push(randomTile(adjacentTileGraphic4.spriteFrames4));
          }
        }
        if (adjacentTile6) {
          if (adjacentTile6.elevation > 0) {
            adjacentTileGraphic6 = adjacentTile6.tileGraphic;
          }
          if (adjacentTileGraphic6 && (blah = tilePriority.indexOf(adjacentTileGraphic6) > priority)) {
            if (!has9) {
              ret.push(randomTile(adjacentTileGraphic6.spriteFrames9));
            }
            if (!has3) {
              ret.push(randomTile(adjacentTileGraphic6.spriteFrames3));
            }
            ret.push(randomTile(adjacentTileGraphic6.spriteFrames6));
          }
        }
        return ret;
      };
      doodadsSpriteFrameFunction = function(x, y, tileMap) {
        var grassCount, i, ret, tree, treeCount, _m, _n, _o, _p;
        ret = [];
        geographicTile = _this.geographicTileMap[x][y];
        if (geographicTile.temperature > 90) {
          temperature = "Hot";
          treeCount = 6;
          grassCount = 4;
        } else if (geographicTile.temperature > 50) {
          temperature = "Temperate";
          treeCount = 4;
          grassCount = 3;
        } else if (geographicTile.temperature > 20) {
          temperature = "Cold";
          treeCount = 2;
          grassCount = 2;
        } else {
          temperature = "Freezing";
          treeCount = 0;
          grassCount = 0;
        }
        if (geographicTile.rainfall > 70) {
          rainfall = "Wet";
          treeCount *= 2;
          grassCount = 0;
        } else if (geographicTile.rainfall > 30) {
          rainfall = "Moist";
          grassCount *= 2;
          if (temperature === "Hot") {
            treeCount = 0;
          }
        } else {
          rainfall = "Dry";
        }
        if (temperature === "Temperate") {
          tree = leafyTree;
        } else if (temperature === "Hot") {
          tree = junglyTree;
        } else {
          tree = pineyTree;
        }
        if (geographicTile.elevation > 0) {
          if (geographicTile.elevation <= 2) {
            if (rainfall === "Wet" || rainfall === "Moist") {
              for (i = _m = 0; 0 <= grassCount ? _m < grassCount : _m > grassCount; i = 0 <= grassCount ? ++_m : --_m) {
                x = Math.floor(Math.random() * _this.tileSize.width / 4 * 3) - _this.tileSize.width / 8 * 3;
                y = -Math.floor(Math.random() * _this.tileSize.height / 4 * 3) + _this.tileSize.width / 8 * 3;
                ret.push({
                  spriteFrame: grassTuft,
                  x: x,
                  y: y
                });
              }
            }
            if (rainfall === "Wet" || rainfall === "Moist") {
              for (i = _n = 0; 0 <= treeCount ? _n < treeCount : _n > treeCount; i = 0 <= treeCount ? ++_n : --_n) {
                x = Math.floor(Math.random() * _this.tileSize.width / 4 * 3) - _this.tileSize.width / 8 * 3;
                y = -Math.floor(Math.random() * _this.tileSize.height / 4 * 3) + _this.tileSize.width / 8 * 3;
                ret.push({
                  spriteFrame: tree,
                  x: x,
                  y: y
                });
              }
            }
          } else if (geographicTile.elevation <= 4) {
            for (i = _o = 0; _o < 1; i = ++_o) {
              x = Math.floor(Math.random() * _this.tileSize.width / 4) - _this.tileSize.width / 8;
              y = -Math.floor(Math.random() * _this.tileSize.height / 4) + _this.tileSize.width / 8;
              ret.push({
                spriteFrame: hill,
                x: x,
                y: y
              });
            }
          } else {
            for (i = _p = 0; _p < 4; i = ++_p) {
              x = Math.floor(Math.random() * _this.tileSize.width / 4 * 3) - _this.tileSize.width / 8 * 3;
              y = -Math.floor(Math.random() * _this.tileSize.height / 4 * 3) + _this.tileSize.width / 8 * 3;
              ret.push({
                spriteFrame: mountain,
                x: x,
                y: y
              });
            }
          }
        }
        return ret;
      };
      return Background.create({
        tileMap: this.geographicTileMap,
        tileMapSize: this.tileMapSize,
        tileSize: this.tileSize,
        parentSprite: layerSprite,
        spatialHash: spatialHash,
        tileSpriteFrameFunction: tileSpriteFrameFunction,
        transitionSpriteFrameFunction: transitionSpriteFrameFunction,
        doodadsSpriteFrameFunction: doodadsSpriteFrameFunction
      });
    };

    return World;

  })();

}).call(this);
